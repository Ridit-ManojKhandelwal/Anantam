"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkanantam"] = self["webpackChunkanantam"] || []).push([["vendors-node_modules_monaco-editor_esm_vs_basic-languages_freemarker2_freemarker2_js"],{

/***/ "./node_modules/monaco-editor/esm/vs/basic-languages/freemarker2/freemarker2.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/basic-languages/freemarker2/freemarker2.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TagAngleInterpolationBracket: () => (/* binding */ TagAngleInterpolationBracket),\n/* harmony export */   TagAngleInterpolationDollar: () => (/* binding */ TagAngleInterpolationDollar),\n/* harmony export */   TagAutoInterpolationBracket: () => (/* binding */ TagAutoInterpolationBracket),\n/* harmony export */   TagAutoInterpolationDollar: () => (/* binding */ TagAutoInterpolationDollar),\n/* harmony export */   TagBracketInterpolationBracket: () => (/* binding */ TagBracketInterpolationBracket),\n/* harmony export */   TagBracketInterpolationDollar: () => (/* binding */ TagBracketInterpolationDollar)\n/* harmony export */ });\n/* harmony import */ var _editor_editor_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../editor/editor.api.js */ \"include-loader!./node_modules/monaco-editor/esm/vs/editor/editor.api.js\");\n/*!-----------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)\n * Released under the MIT license\n * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt\n *-----------------------------------------------------------------------------*/\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\n\n// src/fillers/monaco-editor-core.ts\nvar monaco_editor_core_exports = {};\n__reExport(monaco_editor_core_exports, _editor_editor_api_js__WEBPACK_IMPORTED_MODULE_0__);\n\n\n// src/basic-languages/freemarker2/freemarker2.ts\nvar EMPTY_ELEMENTS = [\n  \"assign\",\n  \"flush\",\n  \"ftl\",\n  \"return\",\n  \"global\",\n  \"import\",\n  \"include\",\n  \"break\",\n  \"continue\",\n  \"local\",\n  \"nested\",\n  \"nt\",\n  \"setting\",\n  \"stop\",\n  \"t\",\n  \"lt\",\n  \"rt\",\n  \"fallback\"\n];\nvar BLOCK_ELEMENTS = [\n  \"attempt\",\n  \"autoesc\",\n  \"autoEsc\",\n  \"compress\",\n  \"comment\",\n  \"escape\",\n  \"noescape\",\n  \"function\",\n  \"if\",\n  \"list\",\n  \"items\",\n  \"sep\",\n  \"macro\",\n  \"noparse\",\n  \"noParse\",\n  \"noautoesc\",\n  \"noAutoEsc\",\n  \"outputformat\",\n  \"switch\",\n  \"visit\",\n  \"recurse\"\n];\nvar TagSyntaxAngle = {\n  close: \">\",\n  id: \"angle\",\n  open: \"<\"\n};\nvar TagSyntaxBracket = {\n  close: \"\\\\]\",\n  id: \"bracket\",\n  open: \"\\\\[\"\n};\nvar TagSyntaxAuto = {\n  close: \"[>\\\\]]\",\n  id: \"auto\",\n  open: \"[<\\\\[]\"\n};\nvar InterpolationSyntaxDollar = {\n  close: \"\\\\}\",\n  id: \"dollar\",\n  open1: \"\\\\$\",\n  open2: \"\\\\{\"\n};\nvar InterpolationSyntaxBracket = {\n  close: \"\\\\]\",\n  id: \"bracket\",\n  open1: \"\\\\[\",\n  open2: \"=\"\n};\nfunction createLangConfiguration(ts) {\n  return {\n    brackets: [\n      [\"<\", \">\"],\n      [\"[\", \"]\"],\n      [\"(\", \")\"],\n      [\"{\", \"}\"]\n    ],\n    comments: {\n      blockComment: [`${ts.open}--`, `--${ts.close}`]\n    },\n    autoCloseBefore: \"\\n\\r\t }]),.:;=\",\n    autoClosingPairs: [\n      { open: \"{\", close: \"}\" },\n      { open: \"[\", close: \"]\" },\n      { open: \"(\", close: \")\" },\n      { open: '\"', close: '\"', notIn: [\"string\"] },\n      { open: \"'\", close: \"'\", notIn: [\"string\"] }\n    ],\n    surroundingPairs: [\n      { open: '\"', close: '\"' },\n      { open: \"'\", close: \"'\" },\n      { open: \"{\", close: \"}\" },\n      { open: \"[\", close: \"]\" },\n      { open: \"(\", close: \")\" },\n      { open: \"<\", close: \">\" }\n    ],\n    folding: {\n      markers: {\n        start: new RegExp(\n          `${ts.open}#(?:${BLOCK_ELEMENTS.join(\"|\")})([^/${ts.close}]*(?!/)${ts.close})[^${ts.open}]*$`\n        ),\n        end: new RegExp(`${ts.open}/#(?:${BLOCK_ELEMENTS.join(\"|\")})[\\\\r\\\\n\\\\t ]*>`)\n      }\n    },\n    onEnterRules: [\n      {\n        beforeText: new RegExp(\n          `${ts.open}#(?!(?:${EMPTY_ELEMENTS.join(\"|\")}))([a-zA-Z_]+)([^/${ts.close}]*(?!/)${ts.close})[^${ts.open}]*$`\n        ),\n        afterText: new RegExp(`^${ts.open}/#([a-zA-Z_]+)[\\\\r\\\\n\\\\t ]*${ts.close}$`),\n        action: {\n          indentAction: monaco_editor_core_exports.languages.IndentAction.IndentOutdent\n        }\n      },\n      {\n        beforeText: new RegExp(\n          `${ts.open}#(?!(?:${EMPTY_ELEMENTS.join(\"|\")}))([a-zA-Z_]+)([^/${ts.close}]*(?!/)${ts.close})[^${ts.open}]*$`\n        ),\n        action: { indentAction: monaco_editor_core_exports.languages.IndentAction.Indent }\n      }\n    ]\n  };\n}\nfunction createLangConfigurationAuto() {\n  return {\n    // Cannot set block comment delimiter in auto mode...\n    // It depends on the content and the cursor position of the file...\n    brackets: [\n      [\"<\", \">\"],\n      [\"[\", \"]\"],\n      [\"(\", \")\"],\n      [\"{\", \"}\"]\n    ],\n    autoCloseBefore: \"\\n\\r\t }]),.:;=\",\n    autoClosingPairs: [\n      { open: \"{\", close: \"}\" },\n      { open: \"[\", close: \"]\" },\n      { open: \"(\", close: \")\" },\n      { open: '\"', close: '\"', notIn: [\"string\"] },\n      { open: \"'\", close: \"'\", notIn: [\"string\"] }\n    ],\n    surroundingPairs: [\n      { open: '\"', close: '\"' },\n      { open: \"'\", close: \"'\" },\n      { open: \"{\", close: \"}\" },\n      { open: \"[\", close: \"]\" },\n      { open: \"(\", close: \")\" },\n      { open: \"<\", close: \">\" }\n    ],\n    folding: {\n      markers: {\n        start: new RegExp(`[<\\\\[]#(?:${BLOCK_ELEMENTS.join(\"|\")})([^/>\\\\]]*(?!/)[>\\\\]])[^<\\\\[]*$`),\n        end: new RegExp(`[<\\\\[]/#(?:${BLOCK_ELEMENTS.join(\"|\")})[\\\\r\\\\n\\\\t ]*>`)\n      }\n    },\n    onEnterRules: [\n      {\n        beforeText: new RegExp(\n          `[<\\\\[]#(?!(?:${EMPTY_ELEMENTS.join(\"|\")}))([a-zA-Z_]+)([^/>\\\\]]*(?!/)[>\\\\]])[^[<\\\\[]]*$`\n        ),\n        afterText: new RegExp(`^[<\\\\[]/#([a-zA-Z_]+)[\\\\r\\\\n\\\\t ]*[>\\\\]]$`),\n        action: {\n          indentAction: monaco_editor_core_exports.languages.IndentAction.IndentOutdent\n        }\n      },\n      {\n        beforeText: new RegExp(\n          `[<\\\\[]#(?!(?:${EMPTY_ELEMENTS.join(\"|\")}))([a-zA-Z_]+)([^/>\\\\]]*(?!/)[>\\\\]])[^[<\\\\[]]*$`\n        ),\n        action: { indentAction: monaco_editor_core_exports.languages.IndentAction.Indent }\n      }\n    ]\n  };\n}\nfunction createMonarchLanguage(ts, is) {\n  const id = `_${ts.id}_${is.id}`;\n  const s = (name) => name.replace(/__id__/g, id);\n  const r = (regexp) => {\n    const source = regexp.source.replace(/__id__/g, id);\n    return new RegExp(source, regexp.flags);\n  };\n  return {\n    // Settings\n    unicode: true,\n    includeLF: false,\n    start: s(\"default__id__\"),\n    ignoreCase: false,\n    defaultToken: \"invalid\",\n    tokenPostfix: `.freemarker2`,\n    brackets: [\n      { open: \"{\", close: \"}\", token: \"delimiter.curly\" },\n      { open: \"[\", close: \"]\", token: \"delimiter.square\" },\n      { open: \"(\", close: \")\", token: \"delimiter.parenthesis\" },\n      { open: \"<\", close: \">\", token: \"delimiter.angle\" }\n    ],\n    // Dynamic RegExp\n    [s(\"open__id__\")]: new RegExp(ts.open),\n    [s(\"close__id__\")]: new RegExp(ts.close),\n    [s(\"iOpen1__id__\")]: new RegExp(is.open1),\n    [s(\"iOpen2__id__\")]: new RegExp(is.open2),\n    [s(\"iClose__id__\")]: new RegExp(is.close),\n    // <#START_TAG : \"<\" | \"<#\" | \"[#\">\n    // <#END_TAG : \"</\" | \"</#\" | \"[/#\">\n    [s(\"startTag__id__\")]: r(/(@open__id__)(#)/),\n    [s(\"endTag__id__\")]: r(/(@open__id__)(\\/#)/),\n    [s(\"startOrEndTag__id__\")]: r(/(@open__id__)(\\/?#)/),\n    // <#CLOSE_TAG1 : (<BLANK>)* (\">\" | \"]\")>\n    [s(\"closeTag1__id__\")]: r(/((?:@blank)*)(@close__id__)/),\n    // <#CLOSE_TAG2 : (<BLANK>)* (\"/\")? (\">\" | \"]\")>\n    [s(\"closeTag2__id__\")]: r(/((?:@blank)*\\/?)(@close__id__)/),\n    // Static RegExp\n    // <#BLANK : \" \" | \"\\t\" | \"\\n\" | \"\\r\">\n    blank: /[ \\t\\n\\r]/,\n    // <FALSE : \"false\">\n    // <TRUE : \"true\">\n    // <IN : \"in\">\n    // <AS : \"as\">\n    // <USING : \"using\">\n    keywords: [\"false\", \"true\", \"in\", \"as\", \"using\"],\n    // Directive names that cannot have an expression parameters and cannot be self-closing\n    // E.g. <#if id==2> ... </#if>\n    directiveStartCloseTag1: /attempt|recover|sep|auto[eE]sc|no(?:autoe|AutoE)sc|compress|default|no[eE]scape|comment|no[pP]arse/,\n    // Directive names that cannot have an expression parameter and can be self-closing\n    // E.g. <#if> ... <#else>  ... </#if>\n    // E.g. <#if> ... <#else /></#if>\n    directiveStartCloseTag2: /else|break|continue|return|stop|flush|t|lt|rt|nt|nested|recurse|fallback|ftl/,\n    // Directive names that can have an expression parameter and cannot be self-closing\n    // E.g. <#if id==2> ... </#if>\n    directiveStartBlank: /if|else[iI]f|list|for[eE]ach|switch|case|assign|global|local|include|import|function|macro|transform|visit|stop|return|call|setting|output[fF]ormat|nested|recurse|escape|ftl|items/,\n    // Directive names that can have an end tag\n    // E.g. </#if>\n    directiveEndCloseTag1: /if|list|items|sep|recover|attempt|for[eE]ach|local|global|assign|function|macro|output[fF]ormat|auto[eE]sc|no(?:autoe|AutoE)sc|compress|transform|switch|escape|no[eE]scape/,\n    // <#ESCAPED_CHAR :\n    //     \"\\\\\"\n    //     (\n    //         (\"n\" | \"t\" | \"r\" | \"f\" | \"b\" | \"g\" | \"l\" | \"a\" | \"\\\\\" | \"'\" | \"\\\"\" | \"{\" | \"=\")\n    //         |\n    //         (\"x\" [\"0\"-\"9\", \"A\"-\"F\", \"a\"-\"f\"])\n    //     )\n    // >\n    // Note: While the JavaCC tokenizer rule only specifies one hex digit,\n    // FreeMarker actually interprets up to 4 hex digits.\n    escapedChar: /\\\\(?:[ntrfbgla\\\\'\"\\{=]|(?:x[0-9A-Fa-f]{1,4}))/,\n    // <#ASCII_DIGIT: [\"0\" - \"9\"]>\n    asciiDigit: /[0-9]/,\n    // <INTEGER : ([\"0\"-\"9\"])+>\n    integer: /[0-9]+/,\n    // <#NON_ESCAPED_ID_START_CHAR:\n    // [\n    // \t  // This was generated on JDK 1.8.0_20 Win64 with src/main/misc/identifierChars/IdentifierCharGenerator.java\n    //    ...\n    // ]\n    nonEscapedIdStartChar: /[\\$@-Z_a-z\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u1FFF\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183-\\u2184\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3006\\u3031-\\u3035\\u303B-\\u303C\\u3040-\\u318F\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3300-\\u337F\\u3400-\\u4DB5\\u4E00-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66E\\uA67F-\\uA697\\uA6A0-\\uA6E5\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8D0-\\uA8D9\\uA8F2-\\uA8F7\\uA8FB\\uA900-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF-\\uA9D9\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5-\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40-\\uFB41\\uFB43-\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]/,\n    // <#ESCAPED_ID_CHAR: \"\\\\\" (\"-\" | \".\" | \":\" | \"#\")>\n    escapedIdChar: /\\\\[\\-\\.:#]/,\n    // <#ID_START_CHAR: <NON_ESCAPED_ID_START_CHAR>|<ESCAPED_ID_CHAR>>\n    idStartChar: /(?:@nonEscapedIdStartChar)|(?:@escapedIdChar)/,\n    // <ID: <ID_START_CHAR> (<ID_START_CHAR>|<ASCII_DIGIT>)*>\n    id: /(?:@idStartChar)(?:(?:@idStartChar)|(?:@asciiDigit))*/,\n    // Certain keywords / operators are allowed to index hashes\n    //\n    // Expression DotVariable(Expression exp) :\n    // {\n    // \tToken t;\n    // }\n    // {\n    // \t\t<DOT>\n    // \t\t(\n    // \t\t\tt = <ID> | t = <TIMES> | t = <DOUBLE_STAR>\n    // \t\t\t|\n    // \t\t\t(\n    // \t\t\t\tt = <LESS_THAN>\n    // \t\t\t\t|\n    // \t\t\t\tt = <LESS_THAN_EQUALS>\n    // \t\t\t\t|\n    // \t\t\t\tt = <ESCAPED_GT>\n    // \t\t\t\t|\n    // \t\t\t\tt = <ESCAPED_GTE>\n    // \t\t\t\t|\n    // \t\t\t\tt = <FALSE>\n    // \t\t\t\t|\n    // \t\t\t\tt = <TRUE>\n    // \t\t\t\t|\n    // \t\t\t\tt = <IN>\n    // \t\t\t\t|\n    // \t\t\t\tt = <AS>\n    // \t\t\t\t|\n    // \t\t\t\tt = <USING>\n    // \t\t\t)\n    // \t\t\t{\n    // \t\t\t\tif (!Character.isLetter(t.image.charAt(0))) {\n    // \t\t\t\t\tthrow new ParseException(t.image + \" is not a valid identifier.\", template, t);\n    // \t\t\t\t}\n    // \t\t\t}\n    // \t\t)\n    // \t\t{\n    // \t\t\tnotListLiteral(exp, \"hash\");\n    // \t\t\tnotStringLiteral(exp, \"hash\");\n    // \t\t\tnotBooleanLiteral(exp, \"hash\");\n    // \t\t\tDot dot = new Dot(exp, t.image);\n    // \t\t\tdot.setLocation(template, exp, t);\n    // \t\t\treturn dot;\n    // \t\t}\n    // }\n    specialHashKeys: /\\*\\*|\\*|false|true|in|as|using/,\n    // <DOUBLE_EQUALS : \"==\">\n    // <EQUALS : \"=\">\n    // <NOT_EQUALS : \"!=\">\n    // <PLUS_EQUALS : \"+=\">\n    // <MINUS_EQUALS : \"-=\">\n    // <TIMES_EQUALS : \"*=\">\n    // <DIV_EQUALS : \"/=\">\n    // <MOD_EQUALS : \"%=\">\n    // <PLUS_PLUS : \"++\">\n    // <MINUS_MINUS : \"--\">\n    // <LESS_THAN_EQUALS : \"lte\" | \"\\\\lte\" | \"<=\" | \"&lt;=\">\n    // <LESS_THAN : \"lt\" | \"\\\\lt\" | \"<\" | \"&lt;\">\n    // <ESCAPED_GTE : \"gte\" | \"\\\\gte\" | \"&gt;=\">\n    // <ESCAPED_GT: \"gt\" | \"\\\\gt\" |  \"&gt;\">\n    // <DOUBLE_STAR : \"**\">\n    // <PLUS : \"+\">\n    // <MINUS : \"-\">\n    // <TIMES : \"*\">\n    // <PERCENT : \"%\">\n    // <AND : \"&\" | \"&&\" | \"&amp;&amp;\" | \"\\\\and\" >\n    // <OR : \"|\" | \"||\">\n    // <EXCLAM : \"!\">\n    // <COMMA : \",\">\n    // <SEMICOLON : \";\">\n    // <COLON : \":\">\n    // <ELLIPSIS : \"...\">\n    // <DOT_DOT_ASTERISK : \"..*\" >\n    // <DOT_DOT_LESS : \"..<\" | \"..!\" >\n    // <DOT_DOT : \"..\">\n    // <EXISTS : \"??\">\n    // <BUILT_IN : \"?\">\n    // <LAMBDA_ARROW : \"->\" | \"-&gt;\">\n    namedSymbols: /&lt;=|&gt;=|\\\\lte|\\\\lt|&lt;|\\\\gte|\\\\gt|&gt;|&amp;&amp;|\\\\and|-&gt;|->|==|!=|\\+=|-=|\\*=|\\/=|%=|\\+\\+|--|<=|&&|\\|\\||:|\\.\\.\\.|\\.\\.\\*|\\.\\.<|\\.\\.!|\\?\\?|=|<|\\+|-|\\*|\\/|%|\\||\\.\\.|\\?|!|&|\\.|,|;/,\n    arrows: [\"->\", \"-&gt;\"],\n    delimiters: [\";\", \":\", \",\", \".\"],\n    stringOperators: [\"lte\", \"lt\", \"gte\", \"gt\"],\n    noParseTags: [\"noparse\", \"noParse\", \"comment\"],\n    tokenizer: {\n      // Parser states\n      // Plain text\n      [s(\"default__id__\")]: [\n        { include: s(\"@directive_token__id__\") },\n        { include: s(\"@interpolation_and_text_token__id__\") }\n      ],\n      // A FreeMarker expression inside a directive, e.g. <#if 2<3>\n      [s(\"fmExpression__id__.directive\")]: [\n        { include: s(\"@blank_and_expression_comment_token__id__\") },\n        { include: s(\"@directive_end_token__id__\") },\n        { include: s(\"@expression_token__id__\") }\n      ],\n      // A FreeMarker expression inside an interpolation, e.g. ${2+3}\n      [s(\"fmExpression__id__.interpolation\")]: [\n        { include: s(\"@blank_and_expression_comment_token__id__\") },\n        { include: s(\"@expression_token__id__\") },\n        { include: s(\"@greater_operators_token__id__\") }\n      ],\n      // In an expression and inside a not-yet closed parenthesis / bracket\n      [s(\"inParen__id__.plain\")]: [\n        { include: s(\"@blank_and_expression_comment_token__id__\") },\n        { include: s(\"@directive_end_token__id__\") },\n        { include: s(\"@expression_token__id__\") }\n      ],\n      [s(\"inParen__id__.gt\")]: [\n        { include: s(\"@blank_and_expression_comment_token__id__\") },\n        { include: s(\"@expression_token__id__\") },\n        { include: s(\"@greater_operators_token__id__\") }\n      ],\n      // Expression for the unified call, e.g. <@createMacro() ... >\n      [s(\"noSpaceExpression__id__\")]: [\n        { include: s(\"@no_space_expression_end_token__id__\") },\n        { include: s(\"@directive_end_token__id__\") },\n        { include: s(\"@expression_token__id__\") }\n      ],\n      // For the function of a unified call. Special case for when the\n      // expression is a simple identifier.\n      // <@join [1,2] \",\">\n      // <@null!join [1,2] \",\">\n      [s(\"unifiedCall__id__\")]: [{ include: s(\"@unified_call_token__id__\") }],\n      // For singly and doubly quoted string (that may contain interpolations)\n      [s(\"singleString__id__\")]: [{ include: s(\"@string_single_token__id__\") }],\n      [s(\"doubleString__id__\")]: [{ include: s(\"@string_double_token__id__\") }],\n      // For singly and doubly quoted string (that may not contain interpolations)\n      [s(\"rawSingleString__id__\")]: [{ include: s(\"@string_single_raw_token__id__\") }],\n      [s(\"rawDoubleString__id__\")]: [{ include: s(\"@string_double_raw_token__id__\") }],\n      // For a comment in an expression\n      // ${ 1 + <#-- comment --> 2}\n      [s(\"expressionComment__id__\")]: [{ include: s(\"@expression_comment_token__id__\") }],\n      // For <#noparse> ... </#noparse>\n      // For <#noParse> ... </#noParse>\n      // For <#comment> ... </#comment>\n      [s(\"noParse__id__\")]: [{ include: s(\"@no_parse_token__id__\") }],\n      // For <#-- ... -->\n      [s(\"terseComment__id__\")]: [{ include: s(\"@terse_comment_token__id__\") }],\n      // Common rules\n      [s(\"directive_token__id__\")]: [\n        // <ATTEMPT : <START_TAG> \"attempt\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <RECOVER : <START_TAG> \"recover\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <SEP : <START_TAG> \"sep\" <CLOSE_TAG1>>\n        // <AUTOESC : <START_TAG> \"auto\" (\"e\"|\"E\") \"sc\" <CLOSE_TAG1>> {\n        //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 4), DEFAULT);\n        // }\n        // <NOAUTOESC : <START_TAG> \"no\" (\"autoe\"|\"AutoE\") \"sc\" <CLOSE_TAG1>> {\n        //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 2), DEFAULT);\n        // }\n        // <COMPRESS : <START_TAG> \"compress\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <DEFAUL : <START_TAG> \"default\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <NOESCAPE : <START_TAG> \"no\" (\"e\" | \"E\") \"scape\" <CLOSE_TAG1>> {\n        //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 2), DEFAULT);\n        // }\n        //\n        // <COMMENT : <START_TAG> \"comment\" <CLOSE_TAG1>> {\n        //     handleTagSyntaxAndSwitch(matchedToken, NO_PARSE); noparseTag = \"comment\";\n        // }\n        // <NOPARSE: <START_TAG> \"no\" (\"p\" | \"P\") \"arse\" <CLOSE_TAG1>> {\n        //     int tagNamingConvention = getTagNamingConvention(matchedToken, 2);\n        //     handleTagSyntaxAndSwitch(matchedToken, tagNamingConvention, NO_PARSE);\n        //     noparseTag = tagNamingConvention == Configuration.CAMEL_CASE_NAMING_CONVENTION ? \"noParse\" : \"noparse\";\n        // }\n        [\n          r(/(?:@startTag__id__)(@directiveStartCloseTag1)(?:@closeTag1__id__)/),\n          ts.id === \"auto\" ? {\n            cases: {\n              \"$1==<\": { token: \"@rematch\", switchTo: `@default_angle_${is.id}` },\n              \"$1==[\": { token: \"@rematch\", switchTo: `@default_bracket_${is.id}` }\n            }\n          } : [\n            { token: \"@brackets.directive\" },\n            { token: \"delimiter.directive\" },\n            {\n              cases: {\n                \"@noParseTags\": { token: \"tag\", next: s(\"@noParse__id__.$3\") },\n                \"@default\": { token: \"tag\" }\n              }\n            },\n            { token: \"delimiter.directive\" },\n            { token: \"@brackets.directive\" }\n          ]\n        ],\n        // <ELSE : <START_TAG> \"else\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <BREAK : <START_TAG> \"break\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <CONTINUE : <START_TAG> \"continue\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <SIMPLE_RETURN : <START_TAG> \"return\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <HALT : <START_TAG> \"stop\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <FLUSH : <START_TAG> \"flush\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <TRIM : <START_TAG> \"t\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <LTRIM : <START_TAG> \"lt\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <RTRIM : <START_TAG> \"rt\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <NOTRIM : <START_TAG> \"nt\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <SIMPLE_NESTED : <START_TAG> \"nested\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <SIMPLE_RECURSE : <START_TAG> \"recurse\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <FALLBACK : <START_TAG> \"fallback\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <TRIVIAL_FTL_HEADER : (\"<#ftl\" | \"[#ftl\") (\"/\")? (\">\" | \"]\")> { ftlHeader(matchedToken); }\n        [\n          r(/(?:@startTag__id__)(@directiveStartCloseTag2)(?:@closeTag2__id__)/),\n          ts.id === \"auto\" ? {\n            cases: {\n              \"$1==<\": { token: \"@rematch\", switchTo: `@default_angle_${is.id}` },\n              \"$1==[\": { token: \"@rematch\", switchTo: `@default_bracket_${is.id}` }\n            }\n          } : [\n            { token: \"@brackets.directive\" },\n            { token: \"delimiter.directive\" },\n            { token: \"tag\" },\n            { token: \"delimiter.directive\" },\n            { token: \"@brackets.directive\" }\n          ]\n        ],\n        // <IF : <START_TAG> \"if\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <ELSE_IF : <START_TAG> \"else\" (\"i\" | \"I\") \"f\" <BLANK>> {\n        // \thandleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 4), FM_EXPRESSION);\n        // }\n        // <LIST : <START_TAG> \"list\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <FOREACH : <START_TAG> \"for\" (\"e\" | \"E\") \"ach\" <BLANK>> {\n        //    handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 3), FM_EXPRESSION);\n        // }\n        // <SWITCH : <START_TAG> \"switch\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <CASE : <START_TAG> \"case\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <ASSIGN : <START_TAG> \"assign\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <GLOBALASSIGN : <START_TAG> \"global\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <LOCALASSIGN : <START_TAG> \"local\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <_INCLUDE : <START_TAG> \"include\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <IMPORT : <START_TAG> \"import\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <FUNCTION : <START_TAG> \"function\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <MACRO : <START_TAG> \"macro\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <TRANSFORM : <START_TAG> \"transform\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <VISIT : <START_TAG> \"visit\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <STOP : <START_TAG> \"stop\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <RETURN : <START_TAG> \"return\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <CALL : <START_TAG> \"call\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <SETTING : <START_TAG> \"setting\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <OUTPUTFORMAT : <START_TAG> \"output\" (\"f\"|\"F\") \"ormat\" <BLANK>> {\n        //    handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 6), FM_EXPRESSION);\n        // }\n        // <NESTED : <START_TAG> \"nested\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <RECURSE : <START_TAG> \"recurse\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <ESCAPE : <START_TAG> \"escape\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        //\n        // Note: FreeMarker grammar appears to treat the FTL header as a special case,\n        // in order to remove new lines after the header (?), but since we only need\n        // to tokenize for highlighting, we can include this directive here.\n        // <FTL_HEADER : (\"<#ftl\" | \"[#ftl\") <BLANK>> { ftlHeader(matchedToken); }\n        //\n        // Note: FreeMarker grammar appears to treat the items directive as a special case for\n        // the AST parsing process, but since we only need to tokenize, we can include this\n        // directive here.\n        // <ITEMS : <START_TAG> \"items\" (<BLANK>)+ <AS> <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        [\n          r(/(?:@startTag__id__)(@directiveStartBlank)(@blank)/),\n          ts.id === \"auto\" ? {\n            cases: {\n              \"$1==<\": { token: \"@rematch\", switchTo: `@default_angle_${is.id}` },\n              \"$1==[\": { token: \"@rematch\", switchTo: `@default_bracket_${is.id}` }\n            }\n          } : [\n            { token: \"@brackets.directive\" },\n            { token: \"delimiter.directive\" },\n            { token: \"tag\" },\n            { token: \"\", next: s(\"@fmExpression__id__.directive\") }\n          ]\n        ],\n        // <END_IF : <END_TAG> \"if\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_LIST : <END_TAG> \"list\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_SEP : <END_TAG> \"sep\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_RECOVER : <END_TAG> \"recover\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_ATTEMPT : <END_TAG> \"attempt\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_FOREACH : <END_TAG> \"for\" (\"e\" | \"E\") \"ach\" <CLOSE_TAG1>> {\n        //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 3), DEFAULT);\n        // }\n        // <END_LOCAL : <END_TAG> \"local\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_GLOBAL : <END_TAG> \"global\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_ASSIGN : <END_TAG> \"assign\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_FUNCTION : <END_TAG> \"function\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_MACRO : <END_TAG> \"macro\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_OUTPUTFORMAT : <END_TAG> \"output\" (\"f\" | \"F\") \"ormat\" <CLOSE_TAG1>> {\n        //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 6), DEFAULT);\n        // }\n        // <END_AUTOESC : <END_TAG> \"auto\" (\"e\" | \"E\") \"sc\" <CLOSE_TAG1>> {\n        //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 4), DEFAULT);\n        // }\n        // <END_NOAUTOESC : <END_TAG> \"no\" (\"autoe\"|\"AutoE\") \"sc\" <CLOSE_TAG1>> {\n        //   handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 2), DEFAULT);\n        // }\n        // <END_COMPRESS : <END_TAG> \"compress\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_TRANSFORM : <END_TAG> \"transform\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_SWITCH : <END_TAG> \"switch\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_ESCAPE : <END_TAG> \"escape\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_NOESCAPE : <END_TAG> \"no\" (\"e\" | \"E\") \"scape\" <CLOSE_TAG1>> {\n        //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 2), DEFAULT);\n        // }\n        [\n          r(/(?:@endTag__id__)(@directiveEndCloseTag1)(?:@closeTag1__id__)/),\n          ts.id === \"auto\" ? {\n            cases: {\n              \"$1==<\": { token: \"@rematch\", switchTo: `@default_angle_${is.id}` },\n              \"$1==[\": { token: \"@rematch\", switchTo: `@default_bracket_${is.id}` }\n            }\n          } : [\n            { token: \"@brackets.directive\" },\n            { token: \"delimiter.directive\" },\n            { token: \"tag\" },\n            { token: \"delimiter.directive\" },\n            { token: \"@brackets.directive\" }\n          ]\n        ],\n        // <UNIFIED_CALL : \"<@\" | \"[@\" > { unifiedCall(matchedToken); }\n        [\n          r(/(@open__id__)(@)/),\n          ts.id === \"auto\" ? {\n            cases: {\n              \"$1==<\": { token: \"@rematch\", switchTo: `@default_angle_${is.id}` },\n              \"$1==[\": { token: \"@rematch\", switchTo: `@default_bracket_${is.id}` }\n            }\n          } : [\n            { token: \"@brackets.directive\" },\n            { token: \"delimiter.directive\", next: s(\"@unifiedCall__id__\") }\n          ]\n        ],\n        // <UNIFIED_CALL_END : (\"<\" | \"[\") \"/@\" ((<ID>) (\".\"<ID>)*)? <CLOSE_TAG1>> { unifiedCallEnd(matchedToken); }\n        [\n          r(/(@open__id__)(\\/@)((?:(?:@id)(?:\\.(?:@id))*)?)(?:@closeTag1__id__)/),\n          [\n            { token: \"@brackets.directive\" },\n            { token: \"delimiter.directive\" },\n            { token: \"tag\" },\n            { token: \"delimiter.directive\" },\n            { token: \"@brackets.directive\" }\n          ]\n        ],\n        // <TERSE_COMMENT : (\"<\" | \"[\") \"#--\" > { noparseTag = \"-->\"; handleTagSyntaxAndSwitch(matchedToken, NO_PARSE); }\n        [\n          r(/(@open__id__)#--/),\n          ts.id === \"auto\" ? {\n            cases: {\n              \"$1==<\": { token: \"@rematch\", switchTo: `@default_angle_${is.id}` },\n              \"$1==[\": { token: \"@rematch\", switchTo: `@default_bracket_${is.id}` }\n            }\n          } : { token: \"comment\", next: s(\"@terseComment__id__\") }\n        ],\n        // <UNKNOWN_DIRECTIVE : (\"[#\" | \"[/#\" | \"<#\" | \"</#\") ([\"a\"-\"z\", \"A\"-\"Z\", \"_\"])+>\n        [\n          r(/(?:@startOrEndTag__id__)([a-zA-Z_]+)/),\n          ts.id === \"auto\" ? {\n            cases: {\n              \"$1==<\": { token: \"@rematch\", switchTo: `@default_angle_${is.id}` },\n              \"$1==[\": { token: \"@rematch\", switchTo: `@default_bracket_${is.id}` }\n            }\n          } : [\n            { token: \"@brackets.directive\" },\n            { token: \"delimiter.directive\" },\n            { token: \"tag.invalid\", next: s(\"@fmExpression__id__.directive\") }\n          ]\n        ]\n      ],\n      // <DEFAULT, NO_DIRECTIVE> TOKEN :\n      [s(\"interpolation_and_text_token__id__\")]: [\n        // <DOLLAR_INTERPOLATION_OPENING : \"${\"> { startInterpolation(matchedToken); }\n        // <SQUARE_BRACKET_INTERPOLATION_OPENING : \"[=\"> { startInterpolation(matchedToken); }\n        [\n          r(/(@iOpen1__id__)(@iOpen2__id__)/),\n          [\n            { token: is.id === \"bracket\" ? \"@brackets.interpolation\" : \"delimiter.interpolation\" },\n            {\n              token: is.id === \"bracket\" ? \"delimiter.interpolation\" : \"@brackets.interpolation\",\n              next: s(\"@fmExpression__id__.interpolation\")\n            }\n          ]\n        ],\n        // <STATIC_TEXT_FALSE_ALARM : \"$\" | \"#\" | \"<\" | \"[\" | \"{\"> // to handle a lone dollar sign or \"<\" or \"# or <@ with whitespace after\"\n        // <STATIC_TEXT_WS : (\"\\n\" | \"\\r\" | \"\\t\" | \" \")+>\n        // <STATIC_TEXT_NON_WS : (~[\"$\", \"<\", \"#\", \"[\", \"{\", \"\\n\", \"\\r\", \"\\t\", \" \"])+>\n        [/[\\$#<\\[\\{]|(?:@blank)+|[^\\$<#\\[\\{\\n\\r\\t ]+/, { token: \"source\" }]\n      ],\n      // <STRING_LITERAL :\n      // \t(\n      // \t\t\"\\\"\"\n      // \t\t((~[\"\\\"\", \"\\\\\"]) | <ESCAPED_CHAR>)*\n      // \t\t\"\\\"\"\n      // \t)\n      // \t|\n      // \t(\n      // \t\t\"'\"\n      // \t\t((~[\"'\", \"\\\\\"]) | <ESCAPED_CHAR>)*\n      // \t\t\"'\"\n      // \t)\n      // >\n      [s(\"string_single_token__id__\")]: [\n        [/[^'\\\\]/, { token: \"string\" }],\n        [/@escapedChar/, { token: \"string.escape\" }],\n        [/'/, { token: \"string\", next: \"@pop\" }]\n      ],\n      [s(\"string_double_token__id__\")]: [\n        [/[^\"\\\\]/, { token: \"string\" }],\n        [/@escapedChar/, { token: \"string.escape\" }],\n        [/\"/, { token: \"string\", next: \"@pop\" }]\n      ],\n      // <RAW_STRING : \"r\" ((\"\\\"\" (~[\"\\\"\"])* \"\\\"\") | (\"'\" (~[\"'\"])* \"'\"))>\n      [s(\"string_single_raw_token__id__\")]: [\n        [/[^']+/, { token: \"string.raw\" }],\n        [/'/, { token: \"string.raw\", next: \"@pop\" }]\n      ],\n      [s(\"string_double_raw_token__id__\")]: [\n        [/[^\"]+/, { token: \"string.raw\" }],\n        [/\"/, { token: \"string.raw\", next: \"@pop\" }]\n      ],\n      // <FM_EXPRESSION, IN_PAREN, NO_SPACE_EXPRESSION, NAMED_PARAMETER_EXPRESSION> TOKEN :\n      [s(\"expression_token__id__\")]: [\n        // Strings\n        [\n          /(r?)(['\"])/,\n          {\n            cases: {\n              \"r'\": [\n                { token: \"keyword\" },\n                { token: \"string.raw\", next: s(\"@rawSingleString__id__\") }\n              ],\n              'r\"': [\n                { token: \"keyword\" },\n                { token: \"string.raw\", next: s(\"@rawDoubleString__id__\") }\n              ],\n              \"'\": [{ token: \"source\" }, { token: \"string\", next: s(\"@singleString__id__\") }],\n              '\"': [{ token: \"source\" }, { token: \"string\", next: s(\"@doubleString__id__\") }]\n            }\n          }\n        ],\n        // Numbers\n        // <INTEGER : ([\"0\"-\"9\"])+>\n        // <DECIMAL : <INTEGER> \".\" <INTEGER>>\n        [\n          /(?:@integer)(?:\\.(?:@integer))?/,\n          {\n            cases: {\n              \"(?:@integer)\": { token: \"number\" },\n              \"@default\": { token: \"number.float\" }\n            }\n          }\n        ],\n        // Special hash keys that must not be treated as identifiers\n        // after a period, e.g. a.** is accessing the key \"**\" of a\n        [\n          /(\\.)(@blank*)(@specialHashKeys)/,\n          [{ token: \"delimiter\" }, { token: \"\" }, { token: \"identifier\" }]\n        ],\n        // Symbols / operators\n        [\n          /(?:@namedSymbols)/,\n          {\n            cases: {\n              \"@arrows\": { token: \"meta.arrow\" },\n              \"@delimiters\": { token: \"delimiter\" },\n              \"@default\": { token: \"operators\" }\n            }\n          }\n        ],\n        // Identifiers\n        [\n          /@id/,\n          {\n            cases: {\n              \"@keywords\": { token: \"keyword.$0\" },\n              \"@stringOperators\": { token: \"operators\" },\n              \"@default\": { token: \"identifier\" }\n            }\n          }\n        ],\n        // <OPEN_BRACKET : \"[\">\n        // <CLOSE_BRACKET : \"]\">\n        // <OPEN_PAREN : \"(\">\n        // <CLOSE_PAREN : \")\">\n        // <OPENING_CURLY_BRACKET : \"{\">\n        // <CLOSING_CURLY_BRACKET : \"}\">\n        [\n          /[\\[\\]\\(\\)\\{\\}]/,\n          {\n            cases: {\n              \"\\\\[\": {\n                cases: {\n                  \"$S2==gt\": { token: \"@brackets\", next: s(\"@inParen__id__.gt\") },\n                  \"@default\": { token: \"@brackets\", next: s(\"@inParen__id__.plain\") }\n                }\n              },\n              \"\\\\]\": {\n                cases: {\n                  ...is.id === \"bracket\" ? {\n                    \"$S2==interpolation\": { token: \"@brackets.interpolation\", next: \"@popall\" }\n                  } : {},\n                  // This cannot happen while in auto mode, since this applies only to an\n                  // fmExpression inside a directive. But once we encounter the start of a\n                  // directive, we can establish the tag syntax mode.\n                  ...ts.id === \"bracket\" ? {\n                    \"$S2==directive\": { token: \"@brackets.directive\", next: \"@popall\" }\n                  } : {},\n                  // Ignore mismatched paren\n                  [s(\"$S1==inParen__id__\")]: { token: \"@brackets\", next: \"@pop\" },\n                  \"@default\": { token: \"@brackets\" }\n                }\n              },\n              \"\\\\(\": { token: \"@brackets\", next: s(\"@inParen__id__.gt\") },\n              \"\\\\)\": {\n                cases: {\n                  [s(\"$S1==inParen__id__\")]: { token: \"@brackets\", next: \"@pop\" },\n                  \"@default\": { token: \"@brackets\" }\n                }\n              },\n              \"\\\\{\": {\n                cases: {\n                  \"$S2==gt\": { token: \"@brackets\", next: s(\"@inParen__id__.gt\") },\n                  \"@default\": { token: \"@brackets\", next: s(\"@inParen__id__.plain\") }\n                }\n              },\n              \"\\\\}\": {\n                cases: {\n                  ...is.id === \"bracket\" ? {} : {\n                    \"$S2==interpolation\": { token: \"@brackets.interpolation\", next: \"@popall\" }\n                  },\n                  // Ignore mismatched paren\n                  [s(\"$S1==inParen__id__\")]: { token: \"@brackets\", next: \"@pop\" },\n                  \"@default\": { token: \"@brackets\" }\n                }\n              }\n            }\n          }\n        ],\n        // <OPEN_MISPLACED_INTERPOLATION : \"${\" | \"#{\" | \"[=\">\n        [/\\$\\{/, { token: \"delimiter.invalid\" }]\n      ],\n      // <FM_EXPRESSION, IN_PAREN, NAMED_PARAMETER_EXPRESSION> SKIP :\n      [s(\"blank_and_expression_comment_token__id__\")]: [\n        // < ( \" \" | \"\\t\" | \"\\n\" | \"\\r\" )+ >\n        [/(?:@blank)+/, { token: \"\" }],\n        // < (\"<\" | \"[\") (\"#\" | \"!\") \"--\"> : EXPRESSION_COMMENT\n        [/[<\\[][#!]--/, { token: \"comment\", next: s(\"@expressionComment__id__\") }]\n      ],\n      // <FM_EXPRESSION, NO_SPACE_EXPRESSION, NAMED_PARAMETER_EXPRESSION> TOKEN :\n      [s(\"directive_end_token__id__\")]: [\n        // <DIRECTIVE_END : \">\">\n        // {\n        //     if (inFTLHeader) {\n        //         eatNewline();\n        //         inFTLHeader = false;\n        //     }\n        //     if (squBracTagSyntax || postInterpolationLexState != -1 /* We are in an interpolation */) {\n        //         matchedToken.kind = NATURAL_GT;\n        //     } else {\n        //         SwitchTo(DEFAULT);\n        //     }\n        // }\n        // This cannot happen while in auto mode, since this applies only to an\n        // fmExpression inside a directive. But once we encounter the start of a\n        // directive, we can establish the tag syntax mode.\n        [\n          />/,\n          ts.id === \"bracket\" ? { token: \"operators\" } : { token: \"@brackets.directive\", next: \"@popall\" }\n        ],\n        // <EMPTY_DIRECTIVE_END : \"/>\" | \"/]\">\n        // It is a syntax error to end a tag with the wrong close token\n        // Let's indicate that to the user by not closing the tag\n        [\n          r(/(\\/)(@close__id__)/),\n          [{ token: \"delimiter.directive\" }, { token: \"@brackets.directive\", next: \"@popall\" }]\n        ]\n      ],\n      // <IN_PAREN> TOKEN :\n      [s(\"greater_operators_token__id__\")]: [\n        // <NATURAL_GT : \">\">\n        [/>/, { token: \"operators\" }],\n        // <NATURAL_GTE : \">=\">\n        [/>=/, { token: \"operators\" }]\n      ],\n      // <NO_SPACE_EXPRESSION> TOKEN :\n      [s(\"no_space_expression_end_token__id__\")]: [\n        // <TERMINATING_WHITESPACE :  ([\"\\n\", \"\\r\", \"\\t\", \" \"])+> : FM_EXPRESSION\n        [/(?:@blank)+/, { token: \"\", switchTo: s(\"@fmExpression__id__.directive\") }]\n      ],\n      [s(\"unified_call_token__id__\")]: [\n        // Special case for a call where the expression is just an ID\n        // <UNIFIED_CALL> <ID> <BLANK>+\n        [\n          /(@id)((?:@blank)+)/,\n          [{ token: \"tag\" }, { token: \"\", next: s(\"@fmExpression__id__.directive\") }]\n        ],\n        [\n          r(/(@id)(\\/?)(@close__id__)/),\n          [\n            { token: \"tag\" },\n            { token: \"delimiter.directive\" },\n            { token: \"@brackets.directive\", next: \"@popall\" }\n          ]\n        ],\n        [/./, { token: \"@rematch\", next: s(\"@noSpaceExpression__id__\") }]\n      ],\n      // <NO_PARSE> TOKEN :\n      [s(\"no_parse_token__id__\")]: [\n        // <MAYBE_END :\n        // \t (\"<\" | \"[\")\n        // \t \"/\"\n        // \t (\"#\")?\n        // \t ([\"a\"-\"z\", \"A\"-\"Z\"])+\n        // \t ( \" \" | \"\\t\" | \"\\n\" | \"\\r\" )*\n        // \t (\">\" | \"]\")\n        // >\n        [\n          r(/(@open__id__)(\\/#?)([a-zA-Z]+)((?:@blank)*)(@close__id__)/),\n          {\n            cases: {\n              \"$S2==$3\": [\n                { token: \"@brackets.directive\" },\n                { token: \"delimiter.directive\" },\n                { token: \"tag\" },\n                { token: \"\" },\n                { token: \"@brackets.directive\", next: \"@popall\" }\n              ],\n              \"$S2==comment\": [\n                { token: \"comment\" },\n                { token: \"comment\" },\n                { token: \"comment\" },\n                { token: \"comment\" },\n                { token: \"comment\" }\n              ],\n              \"@default\": [\n                { token: \"source\" },\n                { token: \"source\" },\n                { token: \"source\" },\n                { token: \"source\" },\n                { token: \"source\" }\n              ]\n            }\n          }\n        ],\n        // <KEEP_GOING : (~[\"<\", \"[\", \"-\"])+>\n        // <LONE_LESS_THAN_OR_DASH : [\"<\", \"[\", \"-\"]>\n        [\n          /[^<\\[\\-]+|[<\\[\\-]/,\n          {\n            cases: {\n              \"$S2==comment\": { token: \"comment\" },\n              \"@default\": { token: \"source\" }\n            }\n          }\n        ]\n      ],\n      // <EXPRESSION_COMMENT> SKIP:\n      [s(\"expression_comment_token__id__\")]: [\n        // < \"-->\" | \"--]\">\n        [\n          /--[>\\]]/,\n          {\n            token: \"comment\",\n            next: \"@pop\"\n          }\n        ],\n        // < (~[\"-\", \">\", \"]\"])+ >\n        // < \">\">\n        // < \"]\">\n        // < \"-\">\n        [/[^\\->\\]]+|[>\\]\\-]/, { token: \"comment\" }]\n      ],\n      [s(\"terse_comment_token__id__\")]: [\n        //  <TERSE_COMMENT_END : \"-->\" | \"--]\">\n        [r(/--(?:@close__id__)/), { token: \"comment\", next: \"@popall\" }],\n        // <KEEP_GOING : (~[\"<\", \"[\", \"-\"])+>\n        // <LONE_LESS_THAN_OR_DASH : [\"<\", \"[\", \"-\"]>\n        [/[^<\\[\\-]+|[<\\[\\-]/, { token: \"comment\" }]\n      ]\n    }\n  };\n}\nfunction createMonarchLanguageAuto(is) {\n  const angle = createMonarchLanguage(TagSyntaxAngle, is);\n  const bracket = createMonarchLanguage(TagSyntaxBracket, is);\n  const auto = createMonarchLanguage(TagSyntaxAuto, is);\n  return {\n    // Angle and bracket syntax mode\n    // We switch to one of these once we have determined the mode\n    ...angle,\n    ...bracket,\n    ...auto,\n    // Settings\n    unicode: true,\n    includeLF: false,\n    start: `default_auto_${is.id}`,\n    ignoreCase: false,\n    defaultToken: \"invalid\",\n    tokenPostfix: `.freemarker2`,\n    brackets: [\n      { open: \"{\", close: \"}\", token: \"delimiter.curly\" },\n      { open: \"[\", close: \"]\", token: \"delimiter.square\" },\n      { open: \"(\", close: \")\", token: \"delimiter.parenthesis\" },\n      { open: \"<\", close: \">\", token: \"delimiter.angle\" }\n    ],\n    tokenizer: {\n      ...angle.tokenizer,\n      ...bracket.tokenizer,\n      ...auto.tokenizer\n    }\n  };\n}\nvar TagAngleInterpolationDollar = {\n  conf: createLangConfiguration(TagSyntaxAngle),\n  language: createMonarchLanguage(TagSyntaxAngle, InterpolationSyntaxDollar)\n};\nvar TagBracketInterpolationDollar = {\n  conf: createLangConfiguration(TagSyntaxBracket),\n  language: createMonarchLanguage(TagSyntaxBracket, InterpolationSyntaxDollar)\n};\nvar TagAngleInterpolationBracket = {\n  conf: createLangConfiguration(TagSyntaxAngle),\n  language: createMonarchLanguage(TagSyntaxAngle, InterpolationSyntaxBracket)\n};\nvar TagBracketInterpolationBracket = {\n  conf: createLangConfiguration(TagSyntaxBracket),\n  language: createMonarchLanguage(TagSyntaxBracket, InterpolationSyntaxBracket)\n};\nvar TagAutoInterpolationDollar = {\n  conf: createLangConfigurationAuto(),\n  language: createMonarchLanguageAuto(InterpolationSyntaxDollar)\n};\nvar TagAutoInterpolationBracket = {\n  conf: createLangConfigurationAuto(),\n  language: createMonarchLanguageAuto(InterpolationSyntaxBracket)\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzaWMtbGFuZ3VhZ2VzL2ZyZWVtYXJrZXIyL2ZyZWVtYXJrZXIyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QyxrREFBdUI7QUFDUTs7QUFFdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEtBQUs7QUFDZDtBQUNBO0FBQ0Esd0JBQXdCLFFBQVEsVUFBVSxTQUFTO0FBQ25ELEtBQUs7QUFDTCw2QkFBNkIsTUFBTTtBQUNuQztBQUNBLFFBQVEsUUFBUSxZQUFZLEdBQUc7QUFDL0IsUUFBUSx1QkFBdUI7QUFDL0IsUUFBUSx1QkFBdUI7QUFDL0IsUUFBUSwwQ0FBMEM7QUFDbEQsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRLHVCQUF1QjtBQUMvQixRQUFRLHVCQUF1QjtBQUMvQixRQUFRLFFB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QkFBa0I7QUFDcEMsa0JBQWtCLGtCQUFrQjtBQUNwQyxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkMsa0JBQWtCLGlCQUFpQjtBQUNuQyxrQkFBa0IsaUJBQWlCO0FBQ25DLGtCQUFrQixpQkFBaUI7QUFDbkMsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjtBQUNsRCw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsbUNBQW1DO0FBQ3ZFO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsTUFBTTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsUUFBUSxZQUFZLDZCQUE2QjtBQUN6RCxRQUFRLGtEQUFrRDtBQUMxRCxRQUFRLHVEQUF1RDtBQUMvRCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYW5hbnRhbS8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNpYy1sYW5ndWFnZXMvZnJlZW1hcmtlcjIvZnJlZW1hcmtlcjIuanM/Y2Q3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBWZXJzaW9uOiAwLjUwLjAoYzMyMWQwZmJlY2I1MGFiOGE1MzY1ZmExOTY1NDc2YjBhZTYzZmM4NylcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9tb25hY28tZWRpdG9yL2Jsb2IvbWFpbi9MSUNFTlNFLnR4dFxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2QsIHNlY29uZFRhcmdldCkgPT4gKF9fY29weVByb3BzKHRhcmdldCwgbW9kLCBcImRlZmF1bHRcIiksIHNlY29uZFRhcmdldCAmJiBfX2NvcHlQcm9wcyhzZWNvbmRUYXJnZXQsIG1vZCwgXCJkZWZhdWx0XCIpKTtcblxuLy8gc3JjL2ZpbGxlcnMvbW9uYWNvLWVkaXRvci1jb3JlLnRzXG52YXIgbW9uYWNvX2VkaXRvcl9jb3JlX2V4cG9ydHMgPSB7fTtcbl9fcmVFeHBvcnQobW9uYWNvX2VkaXRvcl9jb3JlX2V4cG9ydHMsIG1vbmFjb19lZGl0b3JfY29yZV9zdGFyKTtcbmltcG9ydCAqIGFzIG1vbmFjb19lZGl0b3JfY29yZV9zdGFyIGZyb20gXCIuLi8uLi9lZGl0b3IvZWRpdG9yLmFwaS5qc1wiO1xuXG4vLyBzcmMvYmFzaWMtbGFuZ3VhZ2VzL2ZyZWVtYXJrZXIyL2ZyZWVtYXJrZXIyLnRzXG52YXIgRU1QVFlfRUxFTUVOVFMgPSBbXG4gIFwiYXNzaWduXCIsXG4gIFwiZmx1c2hcIixcbiAgXCJmdGxcIixcbiAgXCJyZXR1cm5cIixcbiAgXCJnbG9iYWxcIixcbiAgXCJpbXBvcnRcIixcbiAgXCJpbmNsdWRlXCIsXG4gIFwiYnJlYWtcIixcbiAgXCJjb250aW51ZVwiLFxuICBcImxvY2FsXCIsXG4gIFwibmVzdGVkXCIsXG4gIFwibnRcIixcbiAgXCJzZXR0aW5nXCIsXG4gIFwic3RvcFwiLFxuICBcInRcIixcbiAgXCJsdFwiLFxuICBcInJ0XCIsXG4gIFwiZmFsbGJhY2tcIlxuXTtcbnZhciBCTE9DS19FTEVNRU5UUyA9IFtcbiAgXCJhdHRlbXB0XCIsXG4gIFwiYXV0b2VzY1wiLFxuICBcImF1dG9Fc2NcIixcbiAgXCJjb21wcmVzc1wiLFxuICBcImNvbW1lbnRcIixcbiAgXCJlc2NhcGVcIixcbiAgXCJub2VzY2FwZVwiLFxuICBcImZ1bmN0aW9uXCIsXG4gIFwiaWZcIixcbiAgXCJsaXN0XCIsXG4gIFwiaXRlbXNcIixcbiAgXCJzZXBcIixcbiAgXCJtYWNyb1wiLFxuICBcIm5vcGFyc2VcIixcbiAgXCJub1BhcnNlXCIsXG4gIFwibm9hdXRvZXNjXCIsXG4gIFwibm9BdXRvRXNjXCIsXG4gIFwib3V0cHV0Zm9ybWF0XCIsXG4gIFwic3dpdGNoXCIsXG4gIFwidmlzaXRcIixcbiAgXCJyZWN1cnNlXCJcbl07XG52YXIgVGFnU3ludGF4QW5nbGUgPSB7XG4gIGNsb3NlOiBcIj5cIixcbiAgaWQ6IFwiYW5nbGVcIixcbiAgb3BlbjogXCI8XCJcbn07XG52YXIgVGFnU3ludGF4QnJhY2tldCA9IHtcbiAgY2xvc2U6IFwiXFxcXF1cIixcbiAgaWQ6IFwiYnJhY2tldFwiLFxuICBvcGVuOiBcIlxcXFxbXCJcbn07XG52YXIgVGFnU3ludGF4QXV0byA9IHtcbiAgY2xvc2U6IFwiWz5cXFxcXV1cIixcbiAgaWQ6IFwiYXV0b1wiLFxuICBvcGVuOiBcIls8XFxcXFtdXCJcbn07XG52YXIgSW50ZXJwb2xhdGlvblN5bnRheERvbGxhciA9IHtcbiAgY2xvc2U6IFwiXFxcXH1cIixcbiAgaWQ6IFwiZG9sbGFyXCIsXG4gIG9wZW4xOiBcIlxcXFwkXCIsXG4gIG9wZW4yOiBcIlxcXFx7XCJcbn07XG52YXIgSW50ZXJwb2xhdGlvblN5bnRheEJyYWNrZXQgPSB7XG4gIGNsb3NlOiBcIlxcXFxdXCIsXG4gIGlkOiBcImJyYWNrZXRcIixcbiAgb3BlbjE6IFwiXFxcXFtcIixcbiAgb3BlbjI6IFwiPVwiXG59O1xuZnVuY3Rpb24gY3JlYXRlTGFuZ0NvbmZpZ3VyYXRpb24odHMpIHtcbiAgcmV0dXJuIHtcbiAgICBicmFja2V0czogW1xuICAgICAgW1wiPFwiLCBcIj5cIl0sXG4gICAgICBbXCJbXCIsIFwiXVwiXSxcbiAgICAgIFtcIihcIiwgXCIpXCJdLFxuICAgICAgW1wie1wiLCBcIn1cIl1cbiAgICBdLFxuICAgIGNvbW1lbnRzOiB7XG4gICAgICBibG9ja0NvbW1lbnQ6IFtgJHt0cy5vcGVufS0tYCwgYC0tJHt0cy5jbG9zZX1gXVxuICAgIH0sXG4gICAgYXV0b0Nsb3NlQmVmb3JlOiBcIlxcblxcclx0IH1dKSwuOjs9XCIsXG4gICAgYXV0b0Nsb3NpbmdQYWlyczogW1xuICAgICAgeyBvcGVuOiBcIntcIiwgY2xvc2U6IFwifVwiIH0sXG4gICAgICB7IG9wZW46IFwiW1wiLCBjbG9zZTogXCJdXCIgfSxcbiAgICAgIHsgb3BlbjogXCIoXCIsIGNsb3NlOiBcIilcIiB9LFxuICAgICAgeyBvcGVuOiAnXCInLCBjbG9zZTogJ1wiJywgbm90SW46IFtcInN0cmluZ1wiXSB9LFxuICAgICAgeyBvcGVuOiBcIidcIiwgY2xvc2U6IFwiJ1wiLCBub3RJbjogW1wic3RyaW5nXCJdIH1cbiAgICBdLFxuICAgIHN1cnJvdW5kaW5nUGFpcnM6IFtcbiAgICAgIHsgb3BlbjogJ1wiJywgY2xvc2U6ICdcIicgfSxcbiAgICAgIHsgb3BlbjogXCInXCIsIGNsb3NlOiBcIidcIiB9LFxuICAgICAgeyBvcGVuOiBcIntcIiwgY2xvc2U6IFwifVwiIH0sXG4gICAgICB7IG9wZW46IFwiW1wiLCBjbG9zZTogXCJdXCIgfSxcbiAgICAgIHsgb3BlbjogXCIoXCIsIGNsb3NlOiBcIilcIiB9LFxuICAgICAgeyBvcGVuOiBcIjxcIiwgY2xvc2U6IFwiPlwiIH1cbiAgICBdLFxuICAgIGZvbGRpbmc6IHtcbiAgICAgIG1hcmtlcnM6IHtcbiAgICAgICAgc3RhcnQ6IG5ldyBSZWdFeHAoXG4gICAgICAgICAgYCR7dHMub3Blbn0jKD86JHtCTE9DS19FTEVNRU5UUy5qb2luKFwifFwiKX0pKFteLyR7dHMuY2xvc2V9XSooPyEvKSR7dHMuY2xvc2V9KVteJHt0cy5vcGVufV0qJGBcbiAgICAgICAgKSxcbiAgICAgICAgZW5kOiBuZXcgUmVnRXhwKGAke3RzLm9wZW59LyMoPzoke0JMT0NLX0VMRU1FTlRTLmpvaW4oXCJ8XCIpfSlbXFxcXHJcXFxcblxcXFx0IF0qPmApXG4gICAgICB9XG4gICAgfSxcbiAgICBvbkVudGVyUnVsZXM6IFtcbiAgICAgIHtcbiAgICAgICAgYmVmb3JlVGV4dDogbmV3IFJlZ0V4cChcbiAgICAgICAgICBgJHt0cy5vcGVufSMoPyEoPzoke0VNUFRZX0VMRU1FTlRTLmpvaW4oXCJ8XCIpfSkpKFthLXpBLVpfXSspKFteLyR7dHMuY2xvc2V9XSooPyEvKSR7dHMuY2xvc2V9KVteJHt0cy5vcGVufV0qJGBcbiAgICAgICAgKSxcbiAgICAgICAgYWZ0ZXJUZXh0OiBuZXcgUmVnRXhwKGBeJHt0cy5vcGVufS8jKFthLXpBLVpfXSspW1xcXFxyXFxcXG5cXFxcdCBdKiR7dHMuY2xvc2V9JGApLFxuICAgICAgICBhY3Rpb246IHtcbiAgICAgICAgICBpbmRlbnRBY3Rpb246IG1vbmFjb19lZGl0b3JfY29yZV9leHBvcnRzLmxhbmd1YWdlcy5JbmRlbnRBY3Rpb24uSW5kZW50T3V0ZGVudFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWZvcmVUZXh0OiBuZXcgUmVnRXhwKFxuICAgICAgICAgIGAke3RzLm9wZW59Iyg/ISg/OiR7RU1QVFlfRUxFTUVOVFMuam9pbihcInxcIil9KSkoW2EtekEtWl9dKykoW14vJHt0cy5jbG9zZX1dKig/IS8pJHt0cy5jbG9zZX0pW14ke3RzLm9wZW59XSokYFxuICAgICAgICApLFxuICAgICAgICBhY3Rpb246IHsgaW5kZW50QWN0aW9uOiBtb25hY29fZWRpdG9yX2NvcmVfZXhwb3J0cy5sYW5ndWFnZXMuSW5kZW50QWN0aW9uLkluZGVudCB9XG4gICAgICB9XG4gICAgXVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlTGFuZ0NvbmZpZ3VyYXRpb25BdXRvKCkge1xuICByZXR1cm4ge1xuICAgIC8vIENhbm5vdCBzZXQgYmxvY2sgY29tbWVudCBkZWxpbWl0ZXIgaW4gYXV0byBtb2RlLi4uXG4gICAgLy8gSXQgZGVwZW5kcyBvbiB0aGUgY29udGVudCBhbmQgdGhlIGN1cnNvciBwb3NpdGlvbiBvZiB0aGUgZmlsZS4uLlxuICAgIGJyYWNrZXRzOiBbXG4gICAgICBbXCI8XCIsIFwiPlwiXSxcbiAgICAgIFtcIltcIiwgXCJdXCJdLFxuICAgICAgW1wiKFwiLCBcIilcIl0sXG4gICAgICBbXCJ7XCIsIFwifVwiXVxuICAgIF0sXG4gICAgYXV0b0Nsb3NlQmVmb3JlOiBcIlxcblxcclx0IH1dKSwuOjs9XCIsXG4gICAgYXV0b0Nsb3NpbmdQYWlyczogW1xuICAgICAgeyBvcGVuOiBcIntcIiwgY2xvc2U6IFwifVwiIH0sXG4gICAgICB7IG9wZW46IFwiW1wiLCBjbG9zZTogXCJdXCIgfSxcbiAgICAgIHsgb3BlbjogXCIoXCIsIGNsb3NlOiBcIilcIiB9LFxuICAgICAgeyBvcGVuOiAnXCInLCBjbG9zZTogJ1wiJywgbm90SW46IFtcInN0cmluZ1wiXSB9LFxuICAgICAgeyBvcGVuOiBcIidcIiwgY2xvc2U6IFwiJ1wiLCBub3RJbjogW1wic3RyaW5nXCJdIH1cbiAgICBdLFxuICAgIHN1cnJvdW5kaW5nUGFpcnM6IFtcbiAgICAgIHsgb3BlbjogJ1wiJywgY2xvc2U6ICdcIicgfSxcbiAgICAgIHsgb3BlbjogXCInXCIsIGNsb3NlOiBcIidcIiB9LFxuICAgICAgeyBvcGVuOiBcIntcIiwgY2xvc2U6IFwifVwiIH0sXG4gICAgICB7IG9wZW46IFwiW1wiLCBjbG9zZTogXCJdXCIgfSxcbiAgICAgIHsgb3BlbjogXCIoXCIsIGNsb3NlOiBcIilcIiB9LFxuICAgICAgeyBvcGVuOiBcIjxcIiwgY2xvc2U6IFwiPlwiIH1cbiAgICBdLFxuICAgIGZvbGRpbmc6IHtcbiAgICAgIG1hcmtlcnM6IHtcbiAgICAgICAgc3RhcnQ6IG5ldyBSZWdFeHAoYFs8XFxcXFtdIyg/OiR7QkxPQ0tfRUxFTUVOVFMuam9pbihcInxcIil9KShbXi8+XFxcXF1dKig/IS8pWz5cXFxcXV0pW148XFxcXFtdKiRgKSxcbiAgICAgICAgZW5kOiBuZXcgUmVnRXhwKGBbPFxcXFxbXS8jKD86JHtCTE9DS19FTEVNRU5UUy5qb2luKFwifFwiKX0pW1xcXFxyXFxcXG5cXFxcdCBdKj5gKVxuICAgICAgfVxuICAgIH0sXG4gICAgb25FbnRlclJ1bGVzOiBbXG4gICAgICB7XG4gICAgICAgIGJlZm9yZVRleHQ6IG5ldyBSZWdFeHAoXG4gICAgICAgICAgYFs8XFxcXFtdIyg/ISg/OiR7RU1QVFlfRUxFTUVOVFMuam9pbihcInxcIil9KSkoW2EtekEtWl9dKykoW14vPlxcXFxdXSooPyEvKVs+XFxcXF1dKVteWzxcXFxcW11dKiRgXG4gICAgICAgICksXG4gICAgICAgIGFmdGVyVGV4dDogbmV3IFJlZ0V4cChgXls8XFxcXFtdLyMoW2EtekEtWl9dKylbXFxcXHJcXFxcblxcXFx0IF0qWz5cXFxcXV0kYCksXG4gICAgICAgIGFjdGlvbjoge1xuICAgICAgICAgIGluZGVudEFjdGlvbjogbW9uYWNvX2VkaXRvcl9jb3JlX2V4cG9ydHMubGFuZ3VhZ2VzLkluZGVudEFjdGlvbi5JbmRlbnRPdXRkZW50XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZm9yZVRleHQ6IG5ldyBSZWdFeHAoXG4gICAgICAgICAgYFs8XFxcXFtdIyg/ISg/OiR7RU1QVFlfRUxFTUVOVFMuam9pbihcInxcIil9KSkoW2EtekEtWl9dKykoW14vPlxcXFxdXSooPyEvKVs+XFxcXF1dKVteWzxcXFxcW11dKiRgXG4gICAgICAgICksXG4gICAgICAgIGFjdGlvbjogeyBpbmRlbnRBY3Rpb246IG1vbmFjb19lZGl0b3JfY29yZV9leHBvcnRzLmxhbmd1YWdlcy5JbmRlbnRBY3Rpb24uSW5kZW50IH1cbiAgICAgIH1cbiAgICBdXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVNb25hcmNoTGFuZ3VhZ2UodHMsIGlzKSB7XG4gIGNvbnN0IGlkID0gYF8ke3RzLmlkfV8ke2lzLmlkfWA7XG4gIGNvbnN0IHMgPSAobmFtZSkgPT4gbmFtZS5yZXBsYWNlKC9fX2lkX18vZywgaWQpO1xuICBjb25zdCByID0gKHJlZ2V4cCkgPT4ge1xuICAgIGNvbnN0IHNvdXJjZSA9IHJlZ2V4cC5zb3VyY2UucmVwbGFjZSgvX19pZF9fL2csIGlkKTtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChzb3VyY2UsIHJlZ2V4cC5mbGFncyk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgLy8gU2V0dGluZ3NcbiAgICB1bmljb2RlOiB0cnVlLFxuICAgIGluY2x1ZGVMRjogZmFsc2UsXG4gICAgc3RhcnQ6IHMoXCJkZWZhdWx0X19pZF9fXCIpLFxuICAgIGlnbm9yZUNhc2U6IGZhbHNlLFxuICAgIGRlZmF1bHRUb2tlbjogXCJpbnZhbGlkXCIsXG4gICAgdG9rZW5Qb3N0Zml4OiBgLmZyZWVtYXJrZXIyYCxcbiAgICBicmFja2V0czogW1xuICAgICAgeyBvcGVuOiBcIntcIiwgY2xvc2U6IFwifVwiLCB0b2tlbjogXCJkZWxpbWl0ZXIuY3VybHlcIiB9LFxuICAgICAgeyBvcGVuOiBcIltcIiwgY2xvc2U6IFwiXVwiLCB0b2tlbjogXCJkZWxpbWl0ZXIuc3F1YXJlXCIgfSxcbiAgICAgIHsgb3BlbjogXCIoXCIsIGNsb3NlOiBcIilcIiwgdG9rZW46IFwiZGVsaW1pdGVyLnBhcmVudGhlc2lzXCIgfSxcbiAgICAgIHsgb3BlbjogXCI8XCIsIGNsb3NlOiBcIj5cIiwgdG9rZW46IFwiZGVsaW1pdGVyLmFuZ2xlXCIgfVxuICAgIF0sXG4gICAgLy8gRHluYW1pYyBSZWdFeHBcbiAgICBbcyhcIm9wZW5fX2lkX19cIildOiBuZXcgUmVnRXhwKHRzLm9wZW4pLFxuICAgIFtzKFwiY2xvc2VfX2lkX19cIildOiBuZXcgUmVnRXhwKHRzLmNsb3NlKSxcbiAgICBbcyhcImlPcGVuMV9faWRfX1wiKV06IG5ldyBSZWdFeHAoaXMub3BlbjEpLFxuICAgIFtzKFwiaU9wZW4yX19pZF9fXCIpXTogbmV3IFJlZ0V4cChpcy5vcGVuMiksXG4gICAgW3MoXCJpQ2xvc2VfX2lkX19cIildOiBuZXcgUmVnRXhwKGlzLmNsb3NlKSxcbiAgICAvLyA8I1NUQVJUX1RBRyA6IFwiPFwiIHwgXCI8I1wiIHwgXCJbI1wiPlxuICAgIC8vIDwjRU5EX1RBRyA6IFwiPC9cIiB8IFwiPC8jXCIgfCBcIlsvI1wiPlxuICAgIFtzKFwic3RhcnRUYWdfX2lkX19cIildOiByKC8oQG9wZW5fX2lkX18pKCMpLyksXG4gICAgW3MoXCJlbmRUYWdfX2lkX19cIildOiByKC8oQG9wZW5fX2lkX18pKFxcLyMpLyksXG4gICAgW3MoXCJzdGFydE9yRW5kVGFnX19pZF9fXCIpXTogcigvKEBvcGVuX19pZF9fKShcXC8/IykvKSxcbiAgICAvLyA8I0NMT1NFX1RBRzEgOiAoPEJMQU5LPikqIChcIj5cIiB8IFwiXVwiKT5cbiAgICBbcyhcImNsb3NlVGFnMV9faWRfX1wiKV06IHIoLygoPzpAYmxhbmspKikoQGNsb3NlX19pZF9fKS8pLFxuICAgIC8vIDwjQ0xPU0VfVEFHMiA6ICg8QkxBTks+KSogKFwiL1wiKT8gKFwiPlwiIHwgXCJdXCIpPlxuICAgIFtzKFwiY2xvc2VUYWcyX19pZF9fXCIpXTogcigvKCg/OkBibGFuaykqXFwvPykoQGNsb3NlX19pZF9fKS8pLFxuICAgIC8vIFN0YXRpYyBSZWdFeHBcbiAgICAvLyA8I0JMQU5LIDogXCIgXCIgfCBcIlxcdFwiIHwgXCJcXG5cIiB8IFwiXFxyXCI+XG4gICAgYmxhbms6IC9bIFxcdFxcblxccl0vLFxuICAgIC8vIDxGQUxTRSA6IFwiZmFsc2VcIj5cbiAgICAvLyA8VFJVRSA6IFwidHJ1ZVwiPlxuICAgIC8vIDxJTiA6IFwiaW5cIj5cbiAgICAvLyA8QVMgOiBcImFzXCI+XG4gICAgLy8gPFVTSU5HIDogXCJ1c2luZ1wiPlxuICAgIGtleXdvcmRzOiBbXCJmYWxzZVwiLCBcInRydWVcIiwgXCJpblwiLCBcImFzXCIsIFwidXNpbmdcIl0sXG4gICAgLy8gRGlyZWN0aXZlIG5hbWVzIHRoYXQgY2Fubm90IGhhdmUgYW4gZXhwcmVzc2lvbiBwYXJhbWV0ZXJzIGFuZCBjYW5ub3QgYmUgc2VsZi1jbG9zaW5nXG4gICAgLy8gRS5nLiA8I2lmIGlkPT0yPiAuLi4gPC8jaWY+XG4gICAgZGlyZWN0aXZlU3RhcnRDbG9zZVRhZzE6IC9hdHRlbXB0fHJlY292ZXJ8c2VwfGF1dG9bZUVdc2N8bm8oPzphdXRvZXxBdXRvRSlzY3xjb21wcmVzc3xkZWZhdWx0fG5vW2VFXXNjYXBlfGNvbW1lbnR8bm9bcFBdYXJzZS8sXG4gICAgLy8gRGlyZWN0aXZlIG5hbWVzIHRoYXQgY2Fubm90IGhhdmUgYW4gZXhwcmVzc2lvbiBwYXJhbWV0ZXIgYW5kIGNhbiBiZSBzZWxmLWNsb3NpbmdcbiAgICAvLyBFLmcuIDwjaWY+IC4uLiA8I2Vsc2U+ICAuLi4gPC8jaWY+XG4gICAgLy8gRS5nLiA8I2lmPiAuLi4gPCNlbHNlIC8+PC8jaWY+XG4gICAgZGlyZWN0aXZlU3RhcnRDbG9zZVRhZzI6IC9lbHNlfGJyZWFrfGNvbnRpbnVlfHJldHVybnxzdG9wfGZsdXNofHR8bHR8cnR8bnR8bmVzdGVkfHJlY3Vyc2V8ZmFsbGJhY2t8ZnRsLyxcbiAgICAvLyBEaXJlY3RpdmUgbmFtZXMgdGhhdCBjYW4gaGF2ZSBhbiBleHByZXNzaW9uIHBhcmFtZXRlciBhbmQgY2Fubm90IGJlIHNlbGYtY2xvc2luZ1xuICAgIC8vIEUuZy4gPCNpZiBpZD09Mj4gLi4uIDwvI2lmPlxuICAgIGRpcmVjdGl2ZVN0YXJ0Qmxhbms6IC9pZnxlbHNlW2lJXWZ8bGlzdHxmb3JbZUVdYWNofHN3aXRjaHxjYXNlfGFzc2lnbnxnbG9iYWx8bG9jYWx8aW5jbHVkZXxpbXBvcnR8ZnVuY3Rpb258bWFjcm98dHJhbnNmb3JtfHZpc2l0fHN0b3B8cmV0dXJufGNhbGx8c2V0dGluZ3xvdXRwdXRbZkZdb3JtYXR8bmVzdGVkfHJlY3Vyc2V8ZXNjYXBlfGZ0bHxpdGVtcy8sXG4gICAgLy8gRGlyZWN0aXZlIG5hbWVzIHRoYXQgY2FuIGhhdmUgYW4gZW5kIHRhZ1xuICAgIC8vIEUuZy4gPC8jaWY+XG4gICAgZGlyZWN0aXZlRW5kQ2xvc2VUYWcxOiAvaWZ8bGlzdHxpdGVtc3xzZXB8cmVjb3ZlcnxhdHRlbXB0fGZvcltlRV1hY2h8bG9jYWx8Z2xvYmFsfGFzc2lnbnxmdW5jdGlvbnxtYWNyb3xvdXRwdXRbZkZdb3JtYXR8YXV0b1tlRV1zY3xubyg/OmF1dG9lfEF1dG9FKXNjfGNvbXByZXNzfHRyYW5zZm9ybXxzd2l0Y2h8ZXNjYXBlfG5vW2VFXXNjYXBlLyxcbiAgICAvLyA8I0VTQ0FQRURfQ0hBUiA6XG4gICAgLy8gICAgIFwiXFxcXFwiXG4gICAgLy8gICAgIChcbiAgICAvLyAgICAgICAgIChcIm5cIiB8IFwidFwiIHwgXCJyXCIgfCBcImZcIiB8IFwiYlwiIHwgXCJnXCIgfCBcImxcIiB8IFwiYVwiIHwgXCJcXFxcXCIgfCBcIidcIiB8IFwiXFxcIlwiIHwgXCJ7XCIgfCBcIj1cIilcbiAgICAvLyAgICAgICAgIHxcbiAgICAvLyAgICAgICAgIChcInhcIiBbXCIwXCItXCI5XCIsIFwiQVwiLVwiRlwiLCBcImFcIi1cImZcIl0pXG4gICAgLy8gICAgIClcbiAgICAvLyA+XG4gICAgLy8gTm90ZTogV2hpbGUgdGhlIEphdmFDQyB0b2tlbml6ZXIgcnVsZSBvbmx5IHNwZWNpZmllcyBvbmUgaGV4IGRpZ2l0LFxuICAgIC8vIEZyZWVNYXJrZXIgYWN0dWFsbHkgaW50ZXJwcmV0cyB1cCB0byA0IGhleCBkaWdpdHMuXG4gICAgZXNjYXBlZENoYXI6IC9cXFxcKD86W250cmZiZ2xhXFxcXCdcIlxcez1dfCg/OnhbMC05QS1GYS1mXXsxLDR9KSkvLFxuICAgIC8vIDwjQVNDSUlfRElHSVQ6IFtcIjBcIiAtIFwiOVwiXT5cbiAgICBhc2NpaURpZ2l0OiAvWzAtOV0vLFxuICAgIC8vIDxJTlRFR0VSIDogKFtcIjBcIi1cIjlcIl0pKz5cbiAgICBpbnRlZ2VyOiAvWzAtOV0rLyxcbiAgICAvLyA8I05PTl9FU0NBUEVEX0lEX1NUQVJUX0NIQVI6XG4gICAgLy8gW1xuICAgIC8vIFx0ICAvLyBUaGlzIHdhcyBnZW5lcmF0ZWQgb24gSkRLIDEuOC4wXzIwIFdpbjY0IHdpdGggc3JjL21haW4vbWlzYy9pZGVudGlmaWVyQ2hhcnMvSWRlbnRpZmllckNoYXJHZW5lcmF0b3IuamF2YVxuICAgIC8vICAgIC4uLlxuICAgIC8vIF1cbiAgICBub25Fc2NhcGVkSWRTdGFydENoYXI6IC9bXFwkQC1aX2EtelxcdTAwQUFcXHUwMEI1XFx1MDBCQVxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MUZGRlxcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxODMtXFx1MjE4NFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNFRVxcdTJDRjItXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEODAtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTJFMkZcXHUzMDA1LVxcdTMwMDZcXHUzMDMxLVxcdTMwMzVcXHUzMDNCLVxcdTMwM0NcXHUzMDQwLVxcdTMxOEZcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzMzAwLVxcdTMzN0ZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MkJcXHVBNjQwLVxcdUE2NkVcXHVBNjdGLVxcdUE2OTdcXHVBNkEwLVxcdUE2RTVcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3OEVcXHVBNzkwLVxcdUE3OTNcXHVBN0EwLVxcdUE3QUFcXHVBN0Y4LVxcdUE4MDFcXHVBODAzLVxcdUE4MDVcXHVBODA3LVxcdUE4MEFcXHVBODBDLVxcdUE4MjJcXHVBODQwLVxcdUE4NzNcXHVBODgyLVxcdUE4QjNcXHVBOEQwLVxcdUE4RDlcXHVBOEYyLVxcdUE4RjdcXHVBOEZCXFx1QTkwMC1cXHVBOTI1XFx1QTkzMC1cXHVBOTQ2XFx1QTk2MC1cXHVBOTdDXFx1QTk4NC1cXHVBOUIyXFx1QTlDRi1cXHVBOUQ5XFx1QUEwMC1cXHVBQTI4XFx1QUE0MC1cXHVBQTQyXFx1QUE0NC1cXHVBQTRCXFx1QUE1MC1cXHVBQTU5XFx1QUE2MC1cXHVBQTc2XFx1QUE3QVxcdUFBODAtXFx1QUFBRlxcdUFBQjFcXHVBQUI1LVxcdUFBQjZcXHVBQUI5LVxcdUFBQkRcXHVBQUMwXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFQVxcdUFBRjItXFx1QUFGNFxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCQzAtXFx1QUJFMlxcdUFCRjAtXFx1QUJGOVxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMURcXHVGQjFGLVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MC1cXHVGQjQxXFx1RkI0My1cXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYxMC1cXHVGRjE5XFx1RkYyMS1cXHVGRjNBXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXS8sXG4gICAgLy8gPCNFU0NBUEVEX0lEX0NIQVI6IFwiXFxcXFwiIChcIi1cIiB8IFwiLlwiIHwgXCI6XCIgfCBcIiNcIik+XG4gICAgZXNjYXBlZElkQ2hhcjogL1xcXFxbXFwtXFwuOiNdLyxcbiAgICAvLyA8I0lEX1NUQVJUX0NIQVI6IDxOT05fRVNDQVBFRF9JRF9TVEFSVF9DSEFSPnw8RVNDQVBFRF9JRF9DSEFSPj5cbiAgICBpZFN0YXJ0Q2hhcjogLyg/OkBub25Fc2NhcGVkSWRTdGFydENoYXIpfCg/OkBlc2NhcGVkSWRDaGFyKS8sXG4gICAgLy8gPElEOiA8SURfU1RBUlRfQ0hBUj4gKDxJRF9TVEFSVF9DSEFSPnw8QVNDSUlfRElHSVQ+KSo+XG4gICAgaWQ6IC8oPzpAaWRTdGFydENoYXIpKD86KD86QGlkU3RhcnRDaGFyKXwoPzpAYXNjaWlEaWdpdCkpKi8sXG4gICAgLy8gQ2VydGFpbiBrZXl3b3JkcyAvIG9wZXJhdG9ycyBhcmUgYWxsb3dlZCB0byBpbmRleCBoYXNoZXNcbiAgICAvL1xuICAgIC8vIEV4cHJlc3Npb24gRG90VmFyaWFibGUoRXhwcmVzc2lvbiBleHApIDpcbiAgICAvLyB7XG4gICAgLy8gXHRUb2tlbiB0O1xuICAgIC8vIH1cbiAgICAvLyB7XG4gICAgLy8gXHRcdDxET1Q+XG4gICAgLy8gXHRcdChcbiAgICAvLyBcdFx0XHR0ID0gPElEPiB8IHQgPSA8VElNRVM+IHwgdCA9IDxET1VCTEVfU1RBUj5cbiAgICAvLyBcdFx0XHR8XG4gICAgLy8gXHRcdFx0KFxuICAgIC8vIFx0XHRcdFx0dCA9IDxMRVNTX1RIQU4+XG4gICAgLy8gXHRcdFx0XHR8XG4gICAgLy8gXHRcdFx0XHR0ID0gPExFU1NfVEhBTl9FUVVBTFM+XG4gICAgLy8gXHRcdFx0XHR8XG4gICAgLy8gXHRcdFx0XHR0ID0gPEVTQ0FQRURfR1Q+XG4gICAgLy8gXHRcdFx0XHR8XG4gICAgLy8gXHRcdFx0XHR0ID0gPEVTQ0FQRURfR1RFPlxuICAgIC8vIFx0XHRcdFx0fFxuICAgIC8vIFx0XHRcdFx0dCA9IDxGQUxTRT5cbiAgICAvLyBcdFx0XHRcdHxcbiAgICAvLyBcdFx0XHRcdHQgPSA8VFJVRT5cbiAgICAvLyBcdFx0XHRcdHxcbiAgICAvLyBcdFx0XHRcdHQgPSA8SU4+XG4gICAgLy8gXHRcdFx0XHR8XG4gICAgLy8gXHRcdFx0XHR0ID0gPEFTPlxuICAgIC8vIFx0XHRcdFx0fFxuICAgIC8vIFx0XHRcdFx0dCA9IDxVU0lORz5cbiAgICAvLyBcdFx0XHQpXG4gICAgLy8gXHRcdFx0e1xuICAgIC8vIFx0XHRcdFx0aWYgKCFDaGFyYWN0ZXIuaXNMZXR0ZXIodC5pbWFnZS5jaGFyQXQoMCkpKSB7XG4gICAgLy8gXHRcdFx0XHRcdHRocm93IG5ldyBQYXJzZUV4Y2VwdGlvbih0LmltYWdlICsgXCIgaXMgbm90IGEgdmFsaWQgaWRlbnRpZmllci5cIiwgdGVtcGxhdGUsIHQpO1xuICAgIC8vIFx0XHRcdFx0fVxuICAgIC8vIFx0XHRcdH1cbiAgICAvLyBcdFx0KVxuICAgIC8vIFx0XHR7XG4gICAgLy8gXHRcdFx0bm90TGlzdExpdGVyYWwoZXhwLCBcImhhc2hcIik7XG4gICAgLy8gXHRcdFx0bm90U3RyaW5nTGl0ZXJhbChleHAsIFwiaGFzaFwiKTtcbiAgICAvLyBcdFx0XHRub3RCb29sZWFuTGl0ZXJhbChleHAsIFwiaGFzaFwiKTtcbiAgICAvLyBcdFx0XHREb3QgZG90ID0gbmV3IERvdChleHAsIHQuaW1hZ2UpO1xuICAgIC8vIFx0XHRcdGRvdC5zZXRMb2NhdGlvbih0ZW1wbGF0ZSwgZXhwLCB0KTtcbiAgICAvLyBcdFx0XHRyZXR1cm4gZG90O1xuICAgIC8vIFx0XHR9XG4gICAgLy8gfVxuICAgIHNwZWNpYWxIYXNoS2V5czogL1xcKlxcKnxcXCp8ZmFsc2V8dHJ1ZXxpbnxhc3x1c2luZy8sXG4gICAgLy8gPERPVUJMRV9FUVVBTFMgOiBcIj09XCI+XG4gICAgLy8gPEVRVUFMUyA6IFwiPVwiPlxuICAgIC8vIDxOT1RfRVFVQUxTIDogXCIhPVwiPlxuICAgIC8vIDxQTFVTX0VRVUFMUyA6IFwiKz1cIj5cbiAgICAvLyA8TUlOVVNfRVFVQUxTIDogXCItPVwiPlxuICAgIC8vIDxUSU1FU19FUVVBTFMgOiBcIio9XCI+XG4gICAgLy8gPERJVl9FUVVBTFMgOiBcIi89XCI+XG4gICAgLy8gPE1PRF9FUVVBTFMgOiBcIiU9XCI+XG4gICAgLy8gPFBMVVNfUExVUyA6IFwiKytcIj5cbiAgICAvLyA8TUlOVVNfTUlOVVMgOiBcIi0tXCI+XG4gICAgLy8gPExFU1NfVEhBTl9FUVVBTFMgOiBcImx0ZVwiIHwgXCJcXFxcbHRlXCIgfCBcIjw9XCIgfCBcIiZsdDs9XCI+XG4gICAgLy8gPExFU1NfVEhBTiA6IFwibHRcIiB8IFwiXFxcXGx0XCIgfCBcIjxcIiB8IFwiJmx0O1wiPlxuICAgIC8vIDxFU0NBUEVEX0dURSA6IFwiZ3RlXCIgfCBcIlxcXFxndGVcIiB8IFwiJmd0Oz1cIj5cbiAgICAvLyA8RVNDQVBFRF9HVDogXCJndFwiIHwgXCJcXFxcZ3RcIiB8ICBcIiZndDtcIj5cbiAgICAvLyA8RE9VQkxFX1NUQVIgOiBcIioqXCI+XG4gICAgLy8gPFBMVVMgOiBcIitcIj5cbiAgICAvLyA8TUlOVVMgOiBcIi1cIj5cbiAgICAvLyA8VElNRVMgOiBcIipcIj5cbiAgICAvLyA8UEVSQ0VOVCA6IFwiJVwiPlxuICAgIC8vIDxBTkQgOiBcIiZcIiB8IFwiJiZcIiB8IFwiJmFtcDsmYW1wO1wiIHwgXCJcXFxcYW5kXCIgPlxuICAgIC8vIDxPUiA6IFwifFwiIHwgXCJ8fFwiPlxuICAgIC8vIDxFWENMQU0gOiBcIiFcIj5cbiAgICAvLyA8Q09NTUEgOiBcIixcIj5cbiAgICAvLyA8U0VNSUNPTE9OIDogXCI7XCI+XG4gICAgLy8gPENPTE9OIDogXCI6XCI+XG4gICAgLy8gPEVMTElQU0lTIDogXCIuLi5cIj5cbiAgICAvLyA8RE9UX0RPVF9BU1RFUklTSyA6IFwiLi4qXCIgPlxuICAgIC8vIDxET1RfRE9UX0xFU1MgOiBcIi4uPFwiIHwgXCIuLiFcIiA+XG4gICAgLy8gPERPVF9ET1QgOiBcIi4uXCI+XG4gICAgLy8gPEVYSVNUUyA6IFwiPz9cIj5cbiAgICAvLyA8QlVJTFRfSU4gOiBcIj9cIj5cbiAgICAvLyA8TEFNQkRBX0FSUk9XIDogXCItPlwiIHwgXCItJmd0O1wiPlxuICAgIG5hbWVkU3ltYm9sczogLyZsdDs9fCZndDs9fFxcXFxsdGV8XFxcXGx0fCZsdDt8XFxcXGd0ZXxcXFxcZ3R8Jmd0O3wmYW1wOyZhbXA7fFxcXFxhbmR8LSZndDt8LT58PT18IT18XFwrPXwtPXxcXCo9fFxcLz18JT18XFwrXFwrfC0tfDw9fCYmfFxcfFxcfHw6fFxcLlxcLlxcLnxcXC5cXC5cXCp8XFwuXFwuPHxcXC5cXC4hfFxcP1xcP3w9fDx8XFwrfC18XFwqfFxcL3wlfFxcfHxcXC5cXC58XFw/fCF8JnxcXC58LHw7LyxcbiAgICBhcnJvd3M6IFtcIi0+XCIsIFwiLSZndDtcIl0sXG4gICAgZGVsaW1pdGVyczogW1wiO1wiLCBcIjpcIiwgXCIsXCIsIFwiLlwiXSxcbiAgICBzdHJpbmdPcGVyYXRvcnM6IFtcImx0ZVwiLCBcImx0XCIsIFwiZ3RlXCIsIFwiZ3RcIl0sXG4gICAgbm9QYXJzZVRhZ3M6IFtcIm5vcGFyc2VcIiwgXCJub1BhcnNlXCIsIFwiY29tbWVudFwiXSxcbiAgICB0b2tlbml6ZXI6IHtcbiAgICAgIC8vIFBhcnNlciBzdGF0ZXNcbiAgICAgIC8vIFBsYWluIHRleHRcbiAgICAgIFtzKFwiZGVmYXVsdF9faWRfX1wiKV06IFtcbiAgICAgICAgeyBpbmNsdWRlOiBzKFwiQGRpcmVjdGl2ZV90b2tlbl9faWRfX1wiKSB9LFxuICAgICAgICB7IGluY2x1ZGU6IHMoXCJAaW50ZXJwb2xhdGlvbl9hbmRfdGV4dF90b2tlbl9faWRfX1wiKSB9XG4gICAgICBdLFxuICAgICAgLy8gQSBGcmVlTWFya2VyIGV4cHJlc3Npb24gaW5zaWRlIGEgZGlyZWN0aXZlLCBlLmcuIDwjaWYgMjwzPlxuICAgICAgW3MoXCJmbUV4cHJlc3Npb25fX2lkX18uZGlyZWN0aXZlXCIpXTogW1xuICAgICAgICB7IGluY2x1ZGU6IHMoXCJAYmxhbmtfYW5kX2V4cHJlc3Npb25fY29tbWVudF90b2tlbl9faWRfX1wiKSB9LFxuICAgICAgICB7IGluY2x1ZGU6IHMoXCJAZGlyZWN0aXZlX2VuZF90b2tlbl9faWRfX1wiKSB9LFxuICAgICAgICB7IGluY2x1ZGU6IHMoXCJAZXhwcmVzc2lvbl90b2tlbl9faWRfX1wiKSB9XG4gICAgICBdLFxuICAgICAgLy8gQSBGcmVlTWFya2VyIGV4cHJlc3Npb24gaW5zaWRlIGFuIGludGVycG9sYXRpb24sIGUuZy4gJHsyKzN9XG4gICAgICBbcyhcImZtRXhwcmVzc2lvbl9faWRfXy5pbnRlcnBvbGF0aW9uXCIpXTogW1xuICAgICAgICB7IGluY2x1ZGU6IHMoXCJAYmxhbmtfYW5kX2V4cHJlc3Npb25fY29tbWVudF90b2tlbl9faWRfX1wiKSB9LFxuICAgICAgICB7IGluY2x1ZGU6IHMoXCJAZXhwcmVzc2lvbl90b2tlbl9faWRfX1wiKSB9LFxuICAgICAgICB7IGluY2x1ZGU6IHMoXCJAZ3JlYXRlcl9vcGVyYXRvcnNfdG9rZW5fX2lkX19cIikgfVxuICAgICAgXSxcbiAgICAgIC8vIEluIGFuIGV4cHJlc3Npb24gYW5kIGluc2lkZSBhIG5vdC15ZXQgY2xvc2VkIHBhcmVudGhlc2lzIC8gYnJhY2tldFxuICAgICAgW3MoXCJpblBhcmVuX19pZF9fLnBsYWluXCIpXTogW1xuICAgICAgICB7IGluY2x1ZGU6IHMoXCJAYmxhbmtfYW5kX2V4cHJlc3Npb25fY29tbWVudF90b2tlbl9faWRfX1wiKSB9LFxuICAgICAgICB7IGluY2x1ZGU6IHMoXCJAZGlyZWN0aXZlX2VuZF90b2tlbl9faWRfX1wiKSB9LFxuICAgICAgICB7IGluY2x1ZGU6IHMoXCJAZXhwcmVzc2lvbl90b2tlbl9faWRfX1wiKSB9XG4gICAgICBdLFxuICAgICAgW3MoXCJpblBhcmVuX19pZF9fLmd0XCIpXTogW1xuICAgICAgICB7IGluY2x1ZGU6IHMoXCJAYmxhbmtfYW5kX2V4cHJlc3Npb25fY29tbWVudF90b2tlbl9faWRfX1wiKSB9LFxuICAgICAgICB7IGluY2x1ZGU6IHMoXCJAZXhwcmVzc2lvbl90b2tlbl9faWRfX1wiKSB9LFxuICAgICAgICB7IGluY2x1ZGU6IHMoXCJAZ3JlYXRlcl9vcGVyYXRvcnNfdG9rZW5fX2lkX19cIikgfVxuICAgICAgXSxcbiAgICAgIC8vIEV4cHJlc3Npb24gZm9yIHRoZSB1bmlmaWVkIGNhbGwsIGUuZy4gPEBjcmVhdGVNYWNybygpIC4uLiA+XG4gICAgICBbcyhcIm5vU3BhY2VFeHByZXNzaW9uX19pZF9fXCIpXTogW1xuICAgICAgICB7IGluY2x1ZGU6IHMoXCJAbm9fc3BhY2VfZXhwcmVzc2lvbl9lbmRfdG9rZW5fX2lkX19cIikgfSxcbiAgICAgICAgeyBpbmNsdWRlOiBzKFwiQGRpcmVjdGl2ZV9lbmRfdG9rZW5fX2lkX19cIikgfSxcbiAgICAgICAgeyBpbmNsdWRlOiBzKFwiQGV4cHJlc3Npb25fdG9rZW5fX2lkX19cIikgfVxuICAgICAgXSxcbiAgICAgIC8vIEZvciB0aGUgZnVuY3Rpb24gb2YgYSB1bmlmaWVkIGNhbGwuIFNwZWNpYWwgY2FzZSBmb3Igd2hlbiB0aGVcbiAgICAgIC8vIGV4cHJlc3Npb24gaXMgYSBzaW1wbGUgaWRlbnRpZmllci5cbiAgICAgIC8vIDxAam9pbiBbMSwyXSBcIixcIj5cbiAgICAgIC8vIDxAbnVsbCFqb2luIFsxLDJdIFwiLFwiPlxuICAgICAgW3MoXCJ1bmlmaWVkQ2FsbF9faWRfX1wiKV06IFt7IGluY2x1ZGU6IHMoXCJAdW5pZmllZF9jYWxsX3Rva2VuX19pZF9fXCIpIH1dLFxuICAgICAgLy8gRm9yIHNpbmdseSBhbmQgZG91Ymx5IHF1b3RlZCBzdHJpbmcgKHRoYXQgbWF5IGNvbnRhaW4gaW50ZXJwb2xhdGlvbnMpXG4gICAgICBbcyhcInNpbmdsZVN0cmluZ19faWRfX1wiKV06IFt7IGluY2x1ZGU6IHMoXCJAc3RyaW5nX3NpbmdsZV90b2tlbl9faWRfX1wiKSB9XSxcbiAgICAgIFtzKFwiZG91YmxlU3RyaW5nX19pZF9fXCIpXTogW3sgaW5jbHVkZTogcyhcIkBzdHJpbmdfZG91YmxlX3Rva2VuX19pZF9fXCIpIH1dLFxuICAgICAgLy8gRm9yIHNpbmdseSBhbmQgZG91Ymx5IHF1b3RlZCBzdHJpbmcgKHRoYXQgbWF5IG5vdCBjb250YWluIGludGVycG9sYXRpb25zKVxuICAgICAgW3MoXCJyYXdTaW5nbGVTdHJpbmdfX2lkX19cIildOiBbeyBpbmNsdWRlOiBzKFwiQHN0cmluZ19zaW5nbGVfcmF3X3Rva2VuX19pZF9fXCIpIH1dLFxuICAgICAgW3MoXCJyYXdEb3VibGVTdHJpbmdfX2lkX19cIildOiBbeyBpbmNsdWRlOiBzKFwiQHN0cmluZ19kb3VibGVfcmF3X3Rva2VuX19pZF9fXCIpIH1dLFxuICAgICAgLy8gRm9yIGEgY29tbWVudCBpbiBhbiBleHByZXNzaW9uXG4gICAgICAvLyAkeyAxICsgPCMtLSBjb21tZW50IC0tPiAyfVxuICAgICAgW3MoXCJleHByZXNzaW9uQ29tbWVudF9faWRfX1wiKV06IFt7IGluY2x1ZGU6IHMoXCJAZXhwcmVzc2lvbl9jb21tZW50X3Rva2VuX19pZF9fXCIpIH1dLFxuICAgICAgLy8gRm9yIDwjbm9wYXJzZT4gLi4uIDwvI25vcGFyc2U+XG4gICAgICAvLyBGb3IgPCNub1BhcnNlPiAuLi4gPC8jbm9QYXJzZT5cbiAgICAgIC8vIEZvciA8I2NvbW1lbnQ+IC4uLiA8LyNjb21tZW50PlxuICAgICAgW3MoXCJub1BhcnNlX19pZF9fXCIpXTogW3sgaW5jbHVkZTogcyhcIkBub19wYXJzZV90b2tlbl9faWRfX1wiKSB9XSxcbiAgICAgIC8vIEZvciA8Iy0tIC4uLiAtLT5cbiAgICAgIFtzKFwidGVyc2VDb21tZW50X19pZF9fXCIpXTogW3sgaW5jbHVkZTogcyhcIkB0ZXJzZV9jb21tZW50X3Rva2VuX19pZF9fXCIpIH1dLFxuICAgICAgLy8gQ29tbW9uIHJ1bGVzXG4gICAgICBbcyhcImRpcmVjdGl2ZV90b2tlbl9faWRfX1wiKV06IFtcbiAgICAgICAgLy8gPEFUVEVNUFQgOiA8U1RBUlRfVEFHPiBcImF0dGVtcHRcIiA8Q0xPU0VfVEFHMT4+IHsgaGFuZGxlVGFnU3ludGF4QW5kU3dpdGNoKG1hdGNoZWRUb2tlbiwgREVGQVVMVCk7IH1cbiAgICAgICAgLy8gPFJFQ09WRVIgOiA8U1RBUlRfVEFHPiBcInJlY292ZXJcIiA8Q0xPU0VfVEFHMT4+IHsgaGFuZGxlVGFnU3ludGF4QW5kU3dpdGNoKG1hdGNoZWRUb2tlbiwgREVGQVVMVCk7IH1cbiAgICAgICAgLy8gPFNFUCA6IDxTVEFSVF9UQUc+IFwic2VwXCIgPENMT1NFX1RBRzE+PlxuICAgICAgICAvLyA8QVVUT0VTQyA6IDxTVEFSVF9UQUc+IFwiYXV0b1wiIChcImVcInxcIkVcIikgXCJzY1wiIDxDTE9TRV9UQUcxPj4ge1xuICAgICAgICAvLyAgICAgaGFuZGxlVGFnU3ludGF4QW5kU3dpdGNoKG1hdGNoZWRUb2tlbiwgZ2V0VGFnTmFtaW5nQ29udmVudGlvbihtYXRjaGVkVG9rZW4sIDQpLCBERUZBVUxUKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyA8Tk9BVVRPRVNDIDogPFNUQVJUX1RBRz4gXCJub1wiIChcImF1dG9lXCJ8XCJBdXRvRVwiKSBcInNjXCIgPENMT1NFX1RBRzE+PiB7XG4gICAgICAgIC8vICAgICBoYW5kbGVUYWdTeW50YXhBbmRTd2l0Y2gobWF0Y2hlZFRva2VuLCBnZXRUYWdOYW1pbmdDb252ZW50aW9uKG1hdGNoZWRUb2tlbiwgMiksIERFRkFVTFQpO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIDxDT01QUkVTUyA6IDxTVEFSVF9UQUc+IFwiY29tcHJlc3NcIiA8Q0xPU0VfVEFHMT4+IHsgaGFuZGxlVGFnU3ludGF4QW5kU3dpdGNoKG1hdGNoZWRUb2tlbiwgREVGQVVMVCk7IH1cbiAgICAgICAgLy8gPERFRkFVTCA6IDxTVEFSVF9UQUc+IFwiZGVmYXVsdFwiIDxDTE9TRV9UQUcxPj4geyBoYW5kbGVUYWdTeW50YXhBbmRTd2l0Y2gobWF0Y2hlZFRva2VuLCBERUZBVUxUKTsgfVxuICAgICAgICAvLyA8Tk9FU0NBUEUgOiA8U1RBUlRfVEFHPiBcIm5vXCIgKFwiZVwiIHwgXCJFXCIpIFwic2NhcGVcIiA8Q0xPU0VfVEFHMT4+IHtcbiAgICAgICAgLy8gICAgIGhhbmRsZVRhZ1N5bnRheEFuZFN3aXRjaChtYXRjaGVkVG9rZW4sIGdldFRhZ05hbWluZ0NvbnZlbnRpb24obWF0Y2hlZFRva2VuLCAyKSwgREVGQVVMVCk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gPENPTU1FTlQgOiA8U1RBUlRfVEFHPiBcImNvbW1lbnRcIiA8Q0xPU0VfVEFHMT4+IHtcbiAgICAgICAgLy8gICAgIGhhbmRsZVRhZ1N5bnRheEFuZFN3aXRjaChtYXRjaGVkVG9rZW4sIE5PX1BBUlNFKTsgbm9wYXJzZVRhZyA9IFwiY29tbWVudFwiO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIDxOT1BBUlNFOiA8U1RBUlRfVEFHPiBcIm5vXCIgKFwicFwiIHwgXCJQXCIpIFwiYXJzZVwiIDxDTE9TRV9UQUcxPj4ge1xuICAgICAgICAvLyAgICAgaW50IHRhZ05hbWluZ0NvbnZlbnRpb24gPSBnZXRUYWdOYW1pbmdDb252ZW50aW9uKG1hdGNoZWRUb2tlbiwgMik7XG4gICAgICAgIC8vICAgICBoYW5kbGVUYWdTeW50YXhBbmRTd2l0Y2gobWF0Y2hlZFRva2VuLCB0YWdOYW1pbmdDb252ZW50aW9uLCBOT19QQVJTRSk7XG4gICAgICAgIC8vICAgICBub3BhcnNlVGFnID0gdGFnTmFtaW5nQ29udmVudGlvbiA9PSBDb25maWd1cmF0aW9uLkNBTUVMX0NBU0VfTkFNSU5HX0NPTlZFTlRJT04gPyBcIm5vUGFyc2VcIiA6IFwibm9wYXJzZVwiO1xuICAgICAgICAvLyB9XG4gICAgICAgIFtcbiAgICAgICAgICByKC8oPzpAc3RhcnRUYWdfX2lkX18pKEBkaXJlY3RpdmVTdGFydENsb3NlVGFnMSkoPzpAY2xvc2VUYWcxX19pZF9fKS8pLFxuICAgICAgICAgIHRzLmlkID09PSBcImF1dG9cIiA/IHtcbiAgICAgICAgICAgIGNhc2VzOiB7XG4gICAgICAgICAgICAgIFwiJDE9PTxcIjogeyB0b2tlbjogXCJAcmVtYXRjaFwiLCBzd2l0Y2hUbzogYEBkZWZhdWx0X2FuZ2xlXyR7aXMuaWR9YCB9LFxuICAgICAgICAgICAgICBcIiQxPT1bXCI6IHsgdG9rZW46IFwiQHJlbWF0Y2hcIiwgc3dpdGNoVG86IGBAZGVmYXVsdF9icmFja2V0XyR7aXMuaWR9YCB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSA6IFtcbiAgICAgICAgICAgIHsgdG9rZW46IFwiQGJyYWNrZXRzLmRpcmVjdGl2ZVwiIH0sXG4gICAgICAgICAgICB7IHRva2VuOiBcImRlbGltaXRlci5kaXJlY3RpdmVcIiB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjYXNlczoge1xuICAgICAgICAgICAgICAgIFwiQG5vUGFyc2VUYWdzXCI6IHsgdG9rZW46IFwidGFnXCIsIG5leHQ6IHMoXCJAbm9QYXJzZV9faWRfXy4kM1wiKSB9LFxuICAgICAgICAgICAgICAgIFwiQGRlZmF1bHRcIjogeyB0b2tlbjogXCJ0YWdcIiB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7IHRva2VuOiBcImRlbGltaXRlci5kaXJlY3RpdmVcIiB9LFxuICAgICAgICAgICAgeyB0b2tlbjogXCJAYnJhY2tldHMuZGlyZWN0aXZlXCIgfVxuICAgICAgICAgIF1cbiAgICAgICAgXSxcbiAgICAgICAgLy8gPEVMU0UgOiA8U1RBUlRfVEFHPiBcImVsc2VcIiA8Q0xPU0VfVEFHMj4+IHsgaGFuZGxlVGFnU3ludGF4QW5kU3dpdGNoKG1hdGNoZWRUb2tlbiwgREVGQVVMVCk7IH1cbiAgICAgICAgLy8gPEJSRUFLIDogPFNUQVJUX1RBRz4gXCJicmVha1wiIDxDTE9TRV9UQUcyPj4geyBoYW5kbGVUYWdTeW50YXhBbmRTd2l0Y2gobWF0Y2hlZFRva2VuLCBERUZBVUxUKTsgfVxuICAgICAgICAvLyA8Q09OVElOVUUgOiA8U1RBUlRfVEFHPiBcImNvbnRpbnVlXCIgPENMT1NFX1RBRzI+PiB7IGhhbmRsZVRhZ1N5bnRheEFuZFN3aXRjaChtYXRjaGVkVG9rZW4sIERFRkFVTFQpOyB9XG4gICAgICAgIC8vIDxTSU1QTEVfUkVUVVJOIDogPFNUQVJUX1RBRz4gXCJyZXR1cm5cIiA8Q0xPU0VfVEFHMj4+IHsgaGFuZGxlVGFnU3ludGF4QW5kU3dpdGNoKG1hdGNoZWRUb2tlbiwgREVGQVVMVCk7IH1cbiAgICAgICAgLy8gPEhBTFQgOiA8U1RBUlRfVEFHPiBcInN0b3BcIiA8Q0xPU0VfVEFHMj4+IHsgaGFuZGxlVGFnU3ludGF4QW5kU3dpdGNoKG1hdGNoZWRUb2tlbiwgREVGQVVMVCk7IH1cbiAgICAgICAgLy8gPEZMVVNIIDogPFNUQVJUX1RBRz4gXCJmbHVzaFwiIDxDTE9TRV9UQUcyPj4geyBoYW5kbGVUYWdTeW50YXhBbmRTd2l0Y2gobWF0Y2hlZFRva2VuLCBERUZBVUxUKTsgfVxuICAgICAgICAvLyA8VFJJTSA6IDxTVEFSVF9UQUc+IFwidFwiIDxDTE9TRV9UQUcyPj4geyBoYW5kbGVUYWdTeW50YXhBbmRTd2l0Y2gobWF0Y2hlZFRva2VuLCBERUZBVUxUKTsgfVxuICAgICAgICAvLyA8TFRSSU0gOiA8U1RBUlRfVEFHPiBcImx0XCIgPENMT1NFX1RBRzI+PiB7IGhhbmRsZVRhZ1N5bnRheEFuZFN3aXRjaChtYXRjaGVkVG9rZW4sIERFRkFVTFQpOyB9XG4gICAgICAgIC8vIDxSVFJJTSA6IDxTVEFSVF9UQUc+IFwicnRcIiA8Q0xPU0VfVEFHMj4+IHsgaGFuZGxlVGFnU3ludGF4QW5kU3dpdGNoKG1hdGNoZWRUb2tlbiwgREVGQVVMVCk7IH1cbiAgICAgICAgLy8gPE5PVFJJTSA6IDxTVEFSVF9UQUc+IFwibnRcIiA8Q0xPU0VfVEFHMj4+IHsgaGFuZGxlVGFnU3ludGF4QW5kU3dpdGNoKG1hdGNoZWRUb2tlbiwgREVGQVVMVCk7IH1cbiAgICAgICAgLy8gPFNJTVBMRV9ORVNURUQgOiA8U1RBUlRfVEFHPiBcIm5lc3RlZFwiIDxDTE9TRV9UQUcyPj4geyBoYW5kbGVUYWdTeW50YXhBbmRTd2l0Y2gobWF0Y2hlZFRva2VuLCBERUZBVUxUKTsgfVxuICAgICAgICAvLyA8U0lNUExFX1JFQ1VSU0UgOiA8U1RBUlRfVEFHPiBcInJlY3Vyc2VcIiA8Q0xPU0VfVEFHMj4+IHsgaGFuZGxlVGFnU3ludGF4QW5kU3dpdGNoKG1hdGNoZWRUb2tlbiwgREVGQVVMVCk7IH1cbiAgICAgICAgLy8gPEZBTExCQUNLIDogPFNUQVJUX1RBRz4gXCJmYWxsYmFja1wiIDxDTE9TRV9UQUcyPj4geyBoYW5kbGVUYWdTeW50YXhBbmRTd2l0Y2gobWF0Y2hlZFRva2VuLCBERUZBVUxUKTsgfVxuICAgICAgICAvLyA8VFJJVklBTF9GVExfSEVBREVSIDogKFwiPCNmdGxcIiB8IFwiWyNmdGxcIikgKFwiL1wiKT8gKFwiPlwiIHwgXCJdXCIpPiB7IGZ0bEhlYWRlcihtYXRjaGVkVG9rZW4pOyB9XG4gICAgICAgIFtcbiAgICAgICAgICByKC8oPzpAc3RhcnRUYWdfX2lkX18pKEBkaXJlY3RpdmVTdGFydENsb3NlVGFnMikoPzpAY2xvc2VUYWcyX19pZF9fKS8pLFxuICAgICAgICAgIHRzLmlkID09PSBcImF1dG9cIiA/IHtcbiAgICAgICAgICAgIGNhc2VzOiB7XG4gICAgICAgICAgICAgIFwiJDE9PTxcIjogeyB0b2tlbjogXCJAcmVtYXRjaFwiLCBzd2l0Y2hUbzogYEBkZWZhdWx0X2FuZ2xlXyR7aXMuaWR9YCB9LFxuICAgICAgICAgICAgICBcIiQxPT1bXCI6IHsgdG9rZW46IFwiQHJlbWF0Y2hcIiwgc3dpdGNoVG86IGBAZGVmYXVsdF9icmFja2V0XyR7aXMuaWR9YCB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSA6IFtcbiAgICAgICAgICAgIHsgdG9rZW46IFwiQGJyYWNrZXRzLmRpcmVjdGl2ZVwiIH0sXG4gICAgICAgICAgICB7IHRva2VuOiBcImRlbGltaXRlci5kaXJlY3RpdmVcIiB9LFxuICAgICAgICAgICAgeyB0b2tlbjogXCJ0YWdcIiB9LFxuICAgICAgICAgICAgeyB0b2tlbjogXCJkZWxpbWl0ZXIuZGlyZWN0aXZlXCIgfSxcbiAgICAgICAgICAgIHsgdG9rZW46IFwiQGJyYWNrZXRzLmRpcmVjdGl2ZVwiIH1cbiAgICAgICAgICBdXG4gICAgICAgIF0sXG4gICAgICAgIC8vIDxJRiA6IDxTVEFSVF9UQUc+IFwiaWZcIiA8QkxBTks+PiB7IGhhbmRsZVRhZ1N5bnRheEFuZFN3aXRjaChtYXRjaGVkVG9rZW4sIEZNX0VYUFJFU1NJT04pOyB9XG4gICAgICAgIC8vIDxFTFNFX0lGIDogPFNUQVJUX1RBRz4gXCJlbHNlXCIgKFwiaVwiIHwgXCJJXCIpIFwiZlwiIDxCTEFOSz4+IHtcbiAgICAgICAgLy8gXHRoYW5kbGVUYWdTeW50YXhBbmRTd2l0Y2gobWF0Y2hlZFRva2VuLCBnZXRUYWdOYW1pbmdDb252ZW50aW9uKG1hdGNoZWRUb2tlbiwgNCksIEZNX0VYUFJFU1NJT04pO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIDxMSVNUIDogPFNUQVJUX1RBRz4gXCJsaXN0XCIgPEJMQU5LPj4geyBoYW5kbGVUYWdTeW50YXhBbmRTd2l0Y2gobWF0Y2hlZFRva2VuLCBGTV9FWFBSRVNTSU9OKTsgfVxuICAgICAgICAvLyA8Rk9SRUFDSCA6IDxTVEFSVF9UQUc+IFwiZm9yXCIgKFwiZVwiIHwgXCJFXCIpIFwiYWNoXCIgPEJMQU5LPj4ge1xuICAgICAgICAvLyAgICBoYW5kbGVUYWdTeW50YXhBbmRTd2l0Y2gobWF0Y2hlZFRva2VuLCBnZXRUYWdOYW1pbmdDb252ZW50aW9uKG1hdGNoZWRUb2tlbiwgMyksIEZNX0VYUFJFU1NJT04pO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIDxTV0lUQ0ggOiA8U1RBUlRfVEFHPiBcInN3aXRjaFwiIDxCTEFOSz4+IHsgaGFuZGxlVGFnU3ludGF4QW5kU3dpdGNoKG1hdGNoZWRUb2tlbiwgRk1fRVhQUkVTU0lPTik7IH1cbiAgICAgICAgLy8gPENBU0UgOiA8U1RBUlRfVEFHPiBcImNhc2VcIiA8QkxBTks+PiB7IGhhbmRsZVRhZ1N5bnRheEFuZFN3aXRjaChtYXRjaGVkVG9rZW4sIEZNX0VYUFJFU1NJT04pOyB9XG4gICAgICAgIC8vIDxBU1NJR04gOiA8U1RBUlRfVEFHPiBcImFzc2lnblwiIDxCTEFOSz4+IHsgaGFuZGxlVGFnU3ludGF4QW5kU3dpdGNoKG1hdGNoZWRUb2tlbiwgRk1fRVhQUkVTU0lPTik7IH1cbiAgICAgICAgLy8gPEdMT0JBTEFTU0lHTiA6IDxTVEFSVF9UQUc+IFwiZ2xvYmFsXCIgPEJMQU5LPj4geyBoYW5kbGVUYWdTeW50YXhBbmRTd2l0Y2gobWF0Y2hlZFRva2VuLCBGTV9FWFBSRVNTSU9OKTsgfVxuICAgICAgICAvLyA8TE9DQUxBU1NJR04gOiA8U1RBUlRfVEFHPiBcImxvY2FsXCIgPEJMQU5LPj4geyBoYW5kbGVUYWdTeW50YXhBbmRTd2l0Y2gobWF0Y2hlZFRva2VuLCBGTV9FWFBSRVNTSU9OKTsgfVxuICAgICAgICAvLyA8X0lOQ0xVREUgOiA8U1RBUlRfVEFHPiBcImluY2x1ZGVcIiA8QkxBTks+PiB7IGhhbmRsZVRhZ1N5bnRheEFuZFN3aXRjaChtYXRjaGVkVG9rZW4sIEZNX0VYUFJFU1NJT04pOyB9XG4gICAgICAgIC8vIDxJTVBPUlQgOiA8U1RBUlRfVEFHPiBcImltcG9ydFwiIDxCTEFOSz4+IHsgaGFuZGxlVGFnU3ludGF4QW5kU3dpdGNoKG1hdGNoZWRUb2tlbiwgRk1fRVhQUkVTU0lPTik7IH1cbiAgICAgICAgLy8gPEZVTkNUSU9OIDogPFNUQVJUX1RBRz4gXCJmdW5jdGlvblwiIDxCTEFOSz4+IHsgaGFuZGxlVGFnU3ludGF4QW5kU3dpdGNoKG1hdGNoZWRUb2tlbiwgRk1fRVhQUkVTU0lPTik7IH1cbiAgICAgICAgLy8gPE1BQ1JPIDogPFNUQVJUX1RBRz4gXCJtYWNyb1wiIDxCTEFOSz4+IHsgaGFuZGxlVGFnU3ludGF4QW5kU3dpdGNoKG1hdGNoZWRUb2tlbiwgRk1fRVhQUkVTU0lPTik7IH1cbiAgICAgICAgLy8gPFRSQU5TRk9STSA6IDxTVEFSVF9UQUc+IFwidHJhbnNmb3JtXCIgPEJMQU5LPj4geyBoYW5kbGVUYWdTeW50YXhBbmRTd2l0Y2gobWF0Y2hlZFRva2VuLCBGTV9FWFBSRVNTSU9OKTsgfVxuICAgICAgICAvLyA8VklTSVQgOiA8U1RBUlRfVEFHPiBcInZpc2l0XCIgPEJMQU5LPj4geyBoYW5kbGVUYWdTeW50YXhBbmRTd2l0Y2gobWF0Y2hlZFRva2VuLCBGTV9FWFBSRVNTSU9OKTsgfVxuICAgICAgICAvLyA8U1RPUCA6IDxTVEFSVF9UQUc+IFwic3RvcFwiIDxCTEFOSz4+IHsgaGFuZGxlVGFnU3ludGF4QW5kU3dpdGNoKG1hdGNoZWRUb2tlbiwgRk1fRVhQUkVTU0lPTik7IH1cbiAgICAgICAgLy8gPFJFVFVSTiA6IDxTVEFSVF9UQUc+IFwicmV0dXJuXCIgPEJMQU5LPj4geyBoYW5kbGVUYWdTeW50YXhBbmRTd2l0Y2gobWF0Y2hlZFRva2VuLCBGTV9FWFBSRVNTSU9OKTsgfVxuICAgICAgICAvLyA8Q0FMTCA6IDxTVEFSVF9UQUc+IFwiY2FsbFwiIDxCTEFOSz4+IHsgaGFuZGxlVGFnU3ludGF4QW5kU3dpdGNoKG1hdGNoZWRUb2tlbiwgRk1fRVhQUkVTU0lPTik7IH1cbiAgICAgICAgLy8gPFNFVFRJTkcgOiA8U1RBUlRfVEFHPiBcInNldHRpbmdcIiA8QkxBTks+PiB7IGhhbmRsZVRhZ1N5bnRheEFuZFN3aXRjaChtYXRjaGVkVG9rZW4sIEZNX0VYUFJFU1NJT04pOyB9XG4gICAgICAgIC8vIDxPVVRQVVRGT1JNQVQgOiA8U1RBUlRfVEFHPiBcIm91dHB1dFwiIChcImZcInxcIkZcIikgXCJvcm1hdFwiIDxCTEFOSz4+IHtcbiAgICAgICAgLy8gICAgaGFuZGxlVGFnU3ludGF4QW5kU3dpdGNoKG1hdGNoZWRUb2tlbiwgZ2V0VGFnTmFtaW5nQ29udmVudGlvbihtYXRjaGVkVG9rZW4sIDYpLCBGTV9FWFBSRVNTSU9OKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyA8TkVTVEVEIDogPFNUQVJUX1RBRz4gXCJuZXN0ZWRcIiA8QkxBTks+PiB7IGhhbmRsZVRhZ1N5bnRheEFuZFN3aXRjaChtYXRjaGVkVG9rZW4sIEZNX0VYUFJFU1NJT04pOyB9XG4gICAgICAgIC8vIDxSRUNVUlNFIDogPFNUQVJUX1RBRz4gXCJyZWN1cnNlXCIgPEJMQU5LPj4geyBoYW5kbGVUYWdTeW50YXhBbmRTd2l0Y2gobWF0Y2hlZFRva2VuLCBGTV9FWFBSRVNTSU9OKTsgfVxuICAgICAgICAvLyA8RVNDQVBFIDogPFNUQVJUX1RBRz4gXCJlc2NhcGVcIiA8QkxBTks+PiB7IGhhbmRsZVRhZ1N5bnRheEFuZFN3aXRjaChtYXRjaGVkVG9rZW4sIEZNX0VYUFJFU1NJT04pOyB9XG4gICAgICAgIC8vXG4gICAgICAgIC8vIE5vdGU6IEZyZWVNYXJrZXIgZ3JhbW1hciBhcHBlYXJzIHRvIHRyZWF0IHRoZSBGVEwgaGVhZGVyIGFzIGEgc3BlY2lhbCBjYXNlLFxuICAgICAgICAvLyBpbiBvcmRlciB0byByZW1vdmUgbmV3IGxpbmVzIGFmdGVyIHRoZSBoZWFkZXIgKD8pLCBidXQgc2luY2Ugd2Ugb25seSBuZWVkXG4gICAgICAgIC8vIHRvIHRva2VuaXplIGZvciBoaWdobGlnaHRpbmcsIHdlIGNhbiBpbmNsdWRlIHRoaXMgZGlyZWN0aXZlIGhlcmUuXG4gICAgICAgIC8vIDxGVExfSEVBREVSIDogKFwiPCNmdGxcIiB8IFwiWyNmdGxcIikgPEJMQU5LPj4geyBmdGxIZWFkZXIobWF0Y2hlZFRva2VuKTsgfVxuICAgICAgICAvL1xuICAgICAgICAvLyBOb3RlOiBGcmVlTWFya2VyIGdyYW1tYXIgYXBwZWFycyB0byB0cmVhdCB0aGUgaXRlbXMgZGlyZWN0aXZlIGFzIGEgc3BlY2lhbCBjYXNlIGZvclxuICAgICAgICAvLyB0aGUgQVNUIHBhcnNpbmcgcHJvY2VzcywgYnV0IHNpbmNlIHdlIG9ubHkgbmVlZCB0byB0b2tlbml6ZSwgd2UgY2FuIGluY2x1ZGUgdGhpc1xuICAgICAgICAvLyBkaXJlY3RpdmUgaGVyZS5cbiAgICAgICAgLy8gPElURU1TIDogPFNUQVJUX1RBRz4gXCJpdGVtc1wiICg8QkxBTks+KSsgPEFTPiA8QkxBTks+PiB7IGhhbmRsZVRhZ1N5bnRheEFuZFN3aXRjaChtYXRjaGVkVG9rZW4sIEZNX0VYUFJFU1NJT04pOyB9XG4gICAgICAgIFtcbiAgICAgICAgICByKC8oPzpAc3RhcnRUYWdfX2lkX18pKEBkaXJlY3RpdmVTdGFydEJsYW5rKShAYmxhbmspLyksXG4gICAgICAgICAgdHMuaWQgPT09IFwiYXV0b1wiID8ge1xuICAgICAgICAgICAgY2FzZXM6IHtcbiAgICAgICAgICAgICAgXCIkMT09PFwiOiB7IHRva2VuOiBcIkByZW1hdGNoXCIsIHN3aXRjaFRvOiBgQGRlZmF1bHRfYW5nbGVfJHtpcy5pZH1gIH0sXG4gICAgICAgICAgICAgIFwiJDE9PVtcIjogeyB0b2tlbjogXCJAcmVtYXRjaFwiLCBzd2l0Y2hUbzogYEBkZWZhdWx0X2JyYWNrZXRfJHtpcy5pZH1gIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IDogW1xuICAgICAgICAgICAgeyB0b2tlbjogXCJAYnJhY2tldHMuZGlyZWN0aXZlXCIgfSxcbiAgICAgICAgICAgIHsgdG9rZW46IFwiZGVsaW1pdGVyLmRpcmVjdGl2ZVwiIH0sXG4gICAgICAgICAgICB7IHRva2VuOiBcInRhZ1wiIH0sXG4gICAgICAgICAgICB7IHRva2VuOiBcIlwiLCBuZXh0OiBzKFwiQGZtRXhwcmVzc2lvbl9faWRfXy5kaXJlY3RpdmVcIikgfVxuICAgICAgICAgIF1cbiAgICAgICAgXSxcbiAgICAgICAgLy8gPEVORF9JRiA6IDxFTkRfVEFHPiBcImlmXCIgPENMT1NFX1RBRzE+PiB7IGhhbmRsZVRhZ1N5bnRheEFuZFN3aXRjaChtYXRjaGVkVG9rZW4sIERFRkFVTFQpOyB9XG4gICAgICAgIC8vIDxFTkRfTElTVCA6IDxFTkRfVEFHPiBcImxpc3RcIiA8Q0xPU0VfVEFHMT4+IHsgaGFuZGxlVGFnU3ludGF4QW5kU3dpdGNoKG1hdGNoZWRUb2tlbiwgREVGQVVMVCk7IH1cbiAgICAgICAgLy8gPEVORF9TRVAgOiA8RU5EX1RBRz4gXCJzZXBcIiA8Q0xPU0VfVEFHMT4+IHsgaGFuZGxlVGFnU3ludGF4QW5kU3dpdGNoKG1hdGNoZWRUb2tlbiwgREVGQVVMVCk7IH1cbiAgICAgICAgLy8gPEVORF9SRUNPVkVSIDogPEVORF9UQUc+IFwicmVjb3ZlclwiIDxDTE9TRV9UQUcxPj4geyBoYW5kbGVUYWdTeW50YXhBbmRTd2l0Y2gobWF0Y2hlZFRva2VuLCBERUZBVUxUKTsgfVxuICAgICAgICAvLyA8RU5EX0FUVEVNUFQgOiA8RU5EX1RBRz4gXCJhdHRlbXB0XCIgPENMT1NFX1RBRzE+PiB7IGhhbmRsZVRhZ1N5bnRheEFuZFN3aXRjaChtYXRjaGVkVG9rZW4sIERFRkFVTFQpOyB9XG4gICAgICAgIC8vIDxFTkRfRk9SRUFDSCA6IDxFTkRfVEFHPiBcImZvclwiIChcImVcIiB8IFwiRVwiKSBcImFjaFwiIDxDTE9TRV9UQUcxPj4ge1xuICAgICAgICAvLyAgICAgaGFuZGxlVGFnU3ludGF4QW5kU3dpdGNoKG1hdGNoZWRUb2tlbiwgZ2V0VGFnTmFtaW5nQ29udmVudGlvbihtYXRjaGVkVG9rZW4sIDMpLCBERUZBVUxUKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyA8RU5EX0xPQ0FMIDogPEVORF9UQUc+IFwibG9jYWxcIiA8Q0xPU0VfVEFHMT4+IHsgaGFuZGxlVGFnU3ludGF4QW5kU3dpdGNoKG1hdGNoZWRUb2tlbiwgREVGQVVMVCk7IH1cbiAgICAgICAgLy8gPEVORF9HTE9CQUwgOiA8RU5EX1RBRz4gXCJnbG9iYWxcIiA8Q0xPU0VfVEFHMT4+IHsgaGFuZGxlVGFnU3ludGF4QW5kU3dpdGNoKG1hdGNoZWRUb2tlbiwgREVGQVVMVCk7IH1cbiAgICAgICAgLy8gPEVORF9BU1NJR04gOiA8RU5EX1RBRz4gXCJhc3NpZ25cIiA8Q0xPU0VfVEFHMT4+IHsgaGFuZGxlVGFnU3ludGF4QW5kU3dpdGNoKG1hdGNoZWRUb2tlbiwgREVGQVVMVCk7IH1cbiAgICAgICAgLy8gPEVORF9GVU5DVElPTiA6IDxFTkRfVEFHPiBcImZ1bmN0aW9uXCIgPENMT1NFX1RBRzE+PiB7IGhhbmRsZVRhZ1N5bnRheEFuZFN3aXRjaChtYXRjaGVkVG9rZW4sIERFRkFVTFQpOyB9XG4gICAgICAgIC8vIDxFTkRfTUFDUk8gOiA8RU5EX1RBRz4gXCJtYWNyb1wiIDxDTE9TRV9UQUcxPj4geyBoYW5kbGVUYWdTeW50YXhBbmRTd2l0Y2gobWF0Y2hlZFRva2VuLCBERUZBVUxUKTsgfVxuICAgICAgICAvLyA8RU5EX09VVFBVVEZPUk1BVCA6IDxFTkRfVEFHPiBcIm91dHB1dFwiIChcImZcIiB8IFwiRlwiKSBcIm9ybWF0XCIgPENMT1NFX1RBRzE+PiB7XG4gICAgICAgIC8vICAgICBoYW5kbGVUYWdTeW50YXhBbmRTd2l0Y2gobWF0Y2hlZFRva2VuLCBnZXRUYWdOYW1pbmdDb252ZW50aW9uKG1hdGNoZWRUb2tlbiwgNiksIERFRkFVTFQpO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIDxFTkRfQVVUT0VTQyA6IDxFTkRfVEFHPiBcImF1dG9cIiAoXCJlXCIgfCBcIkVcIikgXCJzY1wiIDxDTE9TRV9UQUcxPj4ge1xuICAgICAgICAvLyAgICAgaGFuZGxlVGFnU3ludGF4QW5kU3dpdGNoKG1hdGNoZWRUb2tlbiwgZ2V0VGFnTmFtaW5nQ29udmVudGlvbihtYXRjaGVkVG9rZW4sIDQpLCBERUZBVUxUKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyA8RU5EX05PQVVUT0VTQyA6IDxFTkRfVEFHPiBcIm5vXCIgKFwiYXV0b2VcInxcIkF1dG9FXCIpIFwic2NcIiA8Q0xPU0VfVEFHMT4+IHtcbiAgICAgICAgLy8gICBoYW5kbGVUYWdTeW50YXhBbmRTd2l0Y2gobWF0Y2hlZFRva2VuLCBnZXRUYWdOYW1pbmdDb252ZW50aW9uKG1hdGNoZWRUb2tlbiwgMiksIERFRkFVTFQpO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIDxFTkRfQ09NUFJFU1MgOiA8RU5EX1RBRz4gXCJjb21wcmVzc1wiIDxDTE9TRV9UQUcxPj4geyBoYW5kbGVUYWdTeW50YXhBbmRTd2l0Y2gobWF0Y2hlZFRva2VuLCBERUZBVUxUKTsgfVxuICAgICAgICAvLyA8RU5EX1RSQU5TRk9STSA6IDxFTkRfVEFHPiBcInRyYW5zZm9ybVwiIDxDTE9TRV9UQUcxPj4geyBoYW5kbGVUYWdTeW50YXhBbmRTd2l0Y2gobWF0Y2hlZFRva2VuLCBERUZBVUxUKTsgfVxuICAgICAgICAvLyA8RU5EX1NXSVRDSCA6IDxFTkRfVEFHPiBcInN3aXRjaFwiIDxDTE9TRV9UQUcxPj4geyBoYW5kbGVUYWdTeW50YXhBbmRTd2l0Y2gobWF0Y2hlZFRva2VuLCBERUZBVUxUKTsgfVxuICAgICAgICAvLyA8RU5EX0VTQ0FQRSA6IDxFTkRfVEFHPiBcImVzY2FwZVwiIDxDTE9TRV9UQUcxPj4geyBoYW5kbGVUYWdTeW50YXhBbmRTd2l0Y2gobWF0Y2hlZFRva2VuLCBERUZBVUxUKTsgfVxuICAgICAgICAvLyA8RU5EX05PRVNDQVBFIDogPEVORF9UQUc+IFwibm9cIiAoXCJlXCIgfCBcIkVcIikgXCJzY2FwZVwiIDxDTE9TRV9UQUcxPj4ge1xuICAgICAgICAvLyAgICAgaGFuZGxlVGFnU3ludGF4QW5kU3dpdGNoKG1hdGNoZWRUb2tlbiwgZ2V0VGFnTmFtaW5nQ29udmVudGlvbihtYXRjaGVkVG9rZW4sIDIpLCBERUZBVUxUKTtcbiAgICAgICAgLy8gfVxuICAgICAgICBbXG4gICAgICAgICAgcigvKD86QGVuZFRhZ19faWRfXykoQGRpcmVjdGl2ZUVuZENsb3NlVGFnMSkoPzpAY2xvc2VUYWcxX19pZF9fKS8pLFxuICAgICAgICAgIHRzLmlkID09PSBcImF1dG9cIiA/IHtcbiAgICAgICAgICAgIGNhc2VzOiB7XG4gICAgICAgICAgICAgIFwiJDE9PTxcIjogeyB0b2tlbjogXCJAcmVtYXRjaFwiLCBzd2l0Y2hUbzogYEBkZWZhdWx0X2FuZ2xlXyR7aXMuaWR9YCB9LFxuICAgICAgICAgICAgICBcIiQxPT1bXCI6IHsgdG9rZW46IFwiQHJlbWF0Y2hcIiwgc3dpdGNoVG86IGBAZGVmYXVsdF9icmFja2V0XyR7aXMuaWR9YCB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSA6IFtcbiAgICAgICAgICAgIHsgdG9rZW46IFwiQGJyYWNrZXRzLmRpcmVjdGl2ZVwiIH0sXG4gICAgICAgICAgICB7IHRva2VuOiBcImRlbGltaXRlci5kaXJlY3RpdmVcIiB9LFxuICAgICAgICAgICAgeyB0b2tlbjogXCJ0YWdcIiB9LFxuICAgICAgICAgICAgeyB0b2tlbjogXCJkZWxpbWl0ZXIuZGlyZWN0aXZlXCIgfSxcbiAgICAgICAgICAgIHsgdG9rZW46IFwiQGJyYWNrZXRzLmRpcmVjdGl2ZVwiIH1cbiAgICAgICAgICBdXG4gICAgICAgIF0sXG4gICAgICAgIC8vIDxVTklGSUVEX0NBTEwgOiBcIjxAXCIgfCBcIltAXCIgPiB7IHVuaWZpZWRDYWxsKG1hdGNoZWRUb2tlbik7IH1cbiAgICAgICAgW1xuICAgICAgICAgIHIoLyhAb3Blbl9faWRfXykoQCkvKSxcbiAgICAgICAgICB0cy5pZCA9PT0gXCJhdXRvXCIgPyB7XG4gICAgICAgICAgICBjYXNlczoge1xuICAgICAgICAgICAgICBcIiQxPT08XCI6IHsgdG9rZW46IFwiQHJlbWF0Y2hcIiwgc3dpdGNoVG86IGBAZGVmYXVsdF9hbmdsZV8ke2lzLmlkfWAgfSxcbiAgICAgICAgICAgICAgXCIkMT09W1wiOiB7IHRva2VuOiBcIkByZW1hdGNoXCIsIHN3aXRjaFRvOiBgQGRlZmF1bHRfYnJhY2tldF8ke2lzLmlkfWAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gOiBbXG4gICAgICAgICAgICB7IHRva2VuOiBcIkBicmFja2V0cy5kaXJlY3RpdmVcIiB9LFxuICAgICAgICAgICAgeyB0b2tlbjogXCJkZWxpbWl0ZXIuZGlyZWN0aXZlXCIsIG5leHQ6IHMoXCJAdW5pZmllZENhbGxfX2lkX19cIikgfVxuICAgICAgICAgIF1cbiAgICAgICAgXSxcbiAgICAgICAgLy8gPFVOSUZJRURfQ0FMTF9FTkQgOiAoXCI8XCIgfCBcIltcIikgXCIvQFwiICgoPElEPikgKFwiLlwiPElEPikqKT8gPENMT1NFX1RBRzE+PiB7IHVuaWZpZWRDYWxsRW5kKG1hdGNoZWRUb2tlbik7IH1cbiAgICAgICAgW1xuICAgICAgICAgIHIoLyhAb3Blbl9faWRfXykoXFwvQCkoKD86KD86QGlkKSg/OlxcLig/OkBpZCkpKik/KSg/OkBjbG9zZVRhZzFfX2lkX18pLyksXG4gICAgICAgICAgW1xuICAgICAgICAgICAgeyB0b2tlbjogXCJAYnJhY2tldHMuZGlyZWN0aXZlXCIgfSxcbiAgICAgICAgICAgIHsgdG9rZW46IFwiZGVsaW1pdGVyLmRpcmVjdGl2ZVwiIH0sXG4gICAgICAgICAgICB7IHRva2VuOiBcInRhZ1wiIH0sXG4gICAgICAgICAgICB7IHRva2VuOiBcImRlbGltaXRlci5kaXJlY3RpdmVcIiB9LFxuICAgICAgICAgICAgeyB0b2tlbjogXCJAYnJhY2tldHMuZGlyZWN0aXZlXCIgfVxuICAgICAgICAgIF1cbiAgICAgICAgXSxcbiAgICAgICAgLy8gPFRFUlNFX0NPTU1FTlQgOiAoXCI8XCIgfCBcIltcIikgXCIjLS1cIiA+IHsgbm9wYXJzZVRhZyA9IFwiLS0+XCI7IGhhbmRsZVRhZ1N5bnRheEFuZFN3aXRjaChtYXRjaGVkVG9rZW4sIE5PX1BBUlNFKTsgfVxuICAgICAgICBbXG4gICAgICAgICAgcigvKEBvcGVuX19pZF9fKSMtLS8pLFxuICAgICAgICAgIHRzLmlkID09PSBcImF1dG9cIiA/IHtcbiAgICAgICAgICAgIGNhc2VzOiB7XG4gICAgICAgICAgICAgIFwiJDE9PTxcIjogeyB0b2tlbjogXCJAcmVtYXRjaFwiLCBzd2l0Y2hUbzogYEBkZWZhdWx0X2FuZ2xlXyR7aXMuaWR9YCB9LFxuICAgICAgICAgICAgICBcIiQxPT1bXCI6IHsgdG9rZW46IFwiQHJlbWF0Y2hcIiwgc3dpdGNoVG86IGBAZGVmYXVsdF9icmFja2V0XyR7aXMuaWR9YCB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSA6IHsgdG9rZW46IFwiY29tbWVudFwiLCBuZXh0OiBzKFwiQHRlcnNlQ29tbWVudF9faWRfX1wiKSB9XG4gICAgICAgIF0sXG4gICAgICAgIC8vIDxVTktOT1dOX0RJUkVDVElWRSA6IChcIlsjXCIgfCBcIlsvI1wiIHwgXCI8I1wiIHwgXCI8LyNcIikgKFtcImFcIi1cInpcIiwgXCJBXCItXCJaXCIsIFwiX1wiXSkrPlxuICAgICAgICBbXG4gICAgICAgICAgcigvKD86QHN0YXJ0T3JFbmRUYWdfX2lkX18pKFthLXpBLVpfXSspLyksXG4gICAgICAgICAgdHMuaWQgPT09IFwiYXV0b1wiID8ge1xuICAgICAgICAgICAgY2FzZXM6IHtcbiAgICAgICAgICAgICAgXCIkMT09PFwiOiB7IHRva2VuOiBcIkByZW1hdGNoXCIsIHN3aXRjaFRvOiBgQGRlZmF1bHRfYW5nbGVfJHtpcy5pZH1gIH0sXG4gICAgICAgICAgICAgIFwiJDE9PVtcIjogeyB0b2tlbjogXCJAcmVtYXRjaFwiLCBzd2l0Y2hUbzogYEBkZWZhdWx0X2JyYWNrZXRfJHtpcy5pZH1gIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IDogW1xuICAgICAgICAgICAgeyB0b2tlbjogXCJAYnJhY2tldHMuZGlyZWN0aXZlXCIgfSxcbiAgICAgICAgICAgIHsgdG9rZW46IFwiZGVsaW1pdGVyLmRpcmVjdGl2ZVwiIH0sXG4gICAgICAgICAgICB7IHRva2VuOiBcInRhZy5pbnZhbGlkXCIsIG5leHQ6IHMoXCJAZm1FeHByZXNzaW9uX19pZF9fLmRpcmVjdGl2ZVwiKSB9XG4gICAgICAgICAgXVxuICAgICAgICBdXG4gICAgICBdLFxuICAgICAgLy8gPERFRkFVTFQsIE5PX0RJUkVDVElWRT4gVE9LRU4gOlxuICAgICAgW3MoXCJpbnRlcnBvbGF0aW9uX2FuZF90ZXh0X3Rva2VuX19pZF9fXCIpXTogW1xuICAgICAgICAvLyA8RE9MTEFSX0lOVEVSUE9MQVRJT05fT1BFTklORyA6IFwiJHtcIj4geyBzdGFydEludGVycG9sYXRpb24obWF0Y2hlZFRva2VuKTsgfVxuICAgICAgICAvLyA8U1FVQVJFX0JSQUNLRVRfSU5URVJQT0xBVElPTl9PUEVOSU5HIDogXCJbPVwiPiB7IHN0YXJ0SW50ZXJwb2xhdGlvbihtYXRjaGVkVG9rZW4pOyB9XG4gICAgICAgIFtcbiAgICAgICAgICByKC8oQGlPcGVuMV9faWRfXykoQGlPcGVuMl9faWRfXykvKSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICB7IHRva2VuOiBpcy5pZCA9PT0gXCJicmFja2V0XCIgPyBcIkBicmFja2V0cy5pbnRlcnBvbGF0aW9uXCIgOiBcImRlbGltaXRlci5pbnRlcnBvbGF0aW9uXCIgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdG9rZW46IGlzLmlkID09PSBcImJyYWNrZXRcIiA/IFwiZGVsaW1pdGVyLmludGVycG9sYXRpb25cIiA6IFwiQGJyYWNrZXRzLmludGVycG9sYXRpb25cIixcbiAgICAgICAgICAgICAgbmV4dDogcyhcIkBmbUV4cHJlc3Npb25fX2lkX18uaW50ZXJwb2xhdGlvblwiKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgXSxcbiAgICAgICAgLy8gPFNUQVRJQ19URVhUX0ZBTFNFX0FMQVJNIDogXCIkXCIgfCBcIiNcIiB8IFwiPFwiIHwgXCJbXCIgfCBcIntcIj4gLy8gdG8gaGFuZGxlIGEgbG9uZSBkb2xsYXIgc2lnbiBvciBcIjxcIiBvciBcIiMgb3IgPEAgd2l0aCB3aGl0ZXNwYWNlIGFmdGVyXCJcbiAgICAgICAgLy8gPFNUQVRJQ19URVhUX1dTIDogKFwiXFxuXCIgfCBcIlxcclwiIHwgXCJcXHRcIiB8IFwiIFwiKSs+XG4gICAgICAgIC8vIDxTVEFUSUNfVEVYVF9OT05fV1MgOiAofltcIiRcIiwgXCI8XCIsIFwiI1wiLCBcIltcIiwgXCJ7XCIsIFwiXFxuXCIsIFwiXFxyXCIsIFwiXFx0XCIsIFwiIFwiXSkrPlxuICAgICAgICBbL1tcXCQjPFxcW1xce118KD86QGJsYW5rKSt8W15cXCQ8I1xcW1xce1xcblxcclxcdCBdKy8sIHsgdG9rZW46IFwic291cmNlXCIgfV1cbiAgICAgIF0sXG4gICAgICAvLyA8U1RSSU5HX0xJVEVSQUwgOlxuICAgICAgLy8gXHQoXG4gICAgICAvLyBcdFx0XCJcXFwiXCJcbiAgICAgIC8vIFx0XHQoKH5bXCJcXFwiXCIsIFwiXFxcXFwiXSkgfCA8RVNDQVBFRF9DSEFSPikqXG4gICAgICAvLyBcdFx0XCJcXFwiXCJcbiAgICAgIC8vIFx0KVxuICAgICAgLy8gXHR8XG4gICAgICAvLyBcdChcbiAgICAgIC8vIFx0XHRcIidcIlxuICAgICAgLy8gXHRcdCgofltcIidcIiwgXCJcXFxcXCJdKSB8IDxFU0NBUEVEX0NIQVI+KSpcbiAgICAgIC8vIFx0XHRcIidcIlxuICAgICAgLy8gXHQpXG4gICAgICAvLyA+XG4gICAgICBbcyhcInN0cmluZ19zaW5nbGVfdG9rZW5fX2lkX19cIildOiBbXG4gICAgICAgIFsvW14nXFxcXF0vLCB7IHRva2VuOiBcInN0cmluZ1wiIH1dLFxuICAgICAgICBbL0Blc2NhcGVkQ2hhci8sIHsgdG9rZW46IFwic3RyaW5nLmVzY2FwZVwiIH1dLFxuICAgICAgICBbLycvLCB7IHRva2VuOiBcInN0cmluZ1wiLCBuZXh0OiBcIkBwb3BcIiB9XVxuICAgICAgXSxcbiAgICAgIFtzKFwic3RyaW5nX2RvdWJsZV90b2tlbl9faWRfX1wiKV06IFtcbiAgICAgICAgWy9bXlwiXFxcXF0vLCB7IHRva2VuOiBcInN0cmluZ1wiIH1dLFxuICAgICAgICBbL0Blc2NhcGVkQ2hhci8sIHsgdG9rZW46IFwic3RyaW5nLmVzY2FwZVwiIH1dLFxuICAgICAgICBbL1wiLywgeyB0b2tlbjogXCJzdHJpbmdcIiwgbmV4dDogXCJAcG9wXCIgfV1cbiAgICAgIF0sXG4gICAgICAvLyA8UkFXX1NUUklORyA6IFwiclwiICgoXCJcXFwiXCIgKH5bXCJcXFwiXCJdKSogXCJcXFwiXCIpIHwgKFwiJ1wiICh+W1wiJ1wiXSkqIFwiJ1wiKSk+XG4gICAgICBbcyhcInN0cmluZ19zaW5nbGVfcmF3X3Rva2VuX19pZF9fXCIpXTogW1xuICAgICAgICBbL1teJ10rLywgeyB0b2tlbjogXCJzdHJpbmcucmF3XCIgfV0sXG4gICAgICAgIFsvJy8sIHsgdG9rZW46IFwic3RyaW5nLnJhd1wiLCBuZXh0OiBcIkBwb3BcIiB9XVxuICAgICAgXSxcbiAgICAgIFtzKFwic3RyaW5nX2RvdWJsZV9yYXdfdG9rZW5fX2lkX19cIildOiBbXG4gICAgICAgIFsvW15cIl0rLywgeyB0b2tlbjogXCJzdHJpbmcucmF3XCIgfV0sXG4gICAgICAgIFsvXCIvLCB7IHRva2VuOiBcInN0cmluZy5yYXdcIiwgbmV4dDogXCJAcG9wXCIgfV1cbiAgICAgIF0sXG4gICAgICAvLyA8Rk1fRVhQUkVTU0lPTiwgSU5fUEFSRU4sIE5PX1NQQUNFX0VYUFJFU1NJT04sIE5BTUVEX1BBUkFNRVRFUl9FWFBSRVNTSU9OPiBUT0tFTiA6XG4gICAgICBbcyhcImV4cHJlc3Npb25fdG9rZW5fX2lkX19cIildOiBbXG4gICAgICAgIC8vIFN0cmluZ3NcbiAgICAgICAgW1xuICAgICAgICAgIC8ocj8pKFsnXCJdKS8sXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2FzZXM6IHtcbiAgICAgICAgICAgICAgXCJyJ1wiOiBbXG4gICAgICAgICAgICAgICAgeyB0b2tlbjogXCJrZXl3b3JkXCIgfSxcbiAgICAgICAgICAgICAgICB7IHRva2VuOiBcInN0cmluZy5yYXdcIiwgbmV4dDogcyhcIkByYXdTaW5nbGVTdHJpbmdfX2lkX19cIikgfVxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAnclwiJzogW1xuICAgICAgICAgICAgICAgIHsgdG9rZW46IFwia2V5d29yZFwiIH0sXG4gICAgICAgICAgICAgICAgeyB0b2tlbjogXCJzdHJpbmcucmF3XCIsIG5leHQ6IHMoXCJAcmF3RG91YmxlU3RyaW5nX19pZF9fXCIpIH1cbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgXCInXCI6IFt7IHRva2VuOiBcInNvdXJjZVwiIH0sIHsgdG9rZW46IFwic3RyaW5nXCIsIG5leHQ6IHMoXCJAc2luZ2xlU3RyaW5nX19pZF9fXCIpIH1dLFxuICAgICAgICAgICAgICAnXCInOiBbeyB0b2tlbjogXCJzb3VyY2VcIiB9LCB7IHRva2VuOiBcInN0cmluZ1wiLCBuZXh0OiBzKFwiQGRvdWJsZVN0cmluZ19faWRfX1wiKSB9XVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgLy8gTnVtYmVyc1xuICAgICAgICAvLyA8SU5URUdFUiA6IChbXCIwXCItXCI5XCJdKSs+XG4gICAgICAgIC8vIDxERUNJTUFMIDogPElOVEVHRVI+IFwiLlwiIDxJTlRFR0VSPj5cbiAgICAgICAgW1xuICAgICAgICAgIC8oPzpAaW50ZWdlcikoPzpcXC4oPzpAaW50ZWdlcikpPy8sXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2FzZXM6IHtcbiAgICAgICAgICAgICAgXCIoPzpAaW50ZWdlcilcIjogeyB0b2tlbjogXCJudW1iZXJcIiB9LFxuICAgICAgICAgICAgICBcIkBkZWZhdWx0XCI6IHsgdG9rZW46IFwibnVtYmVyLmZsb2F0XCIgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgLy8gU3BlY2lhbCBoYXNoIGtleXMgdGhhdCBtdXN0IG5vdCBiZSB0cmVhdGVkIGFzIGlkZW50aWZpZXJzXG4gICAgICAgIC8vIGFmdGVyIGEgcGVyaW9kLCBlLmcuIGEuKiogaXMgYWNjZXNzaW5nIHRoZSBrZXkgXCIqKlwiIG9mIGFcbiAgICAgICAgW1xuICAgICAgICAgIC8oXFwuKShAYmxhbmsqKShAc3BlY2lhbEhhc2hLZXlzKS8sXG4gICAgICAgICAgW3sgdG9rZW46IFwiZGVsaW1pdGVyXCIgfSwgeyB0b2tlbjogXCJcIiB9LCB7IHRva2VuOiBcImlkZW50aWZpZXJcIiB9XVxuICAgICAgICBdLFxuICAgICAgICAvLyBTeW1ib2xzIC8gb3BlcmF0b3JzXG4gICAgICAgIFtcbiAgICAgICAgICAvKD86QG5hbWVkU3ltYm9scykvLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNhc2VzOiB7XG4gICAgICAgICAgICAgIFwiQGFycm93c1wiOiB7IHRva2VuOiBcIm1ldGEuYXJyb3dcIiB9LFxuICAgICAgICAgICAgICBcIkBkZWxpbWl0ZXJzXCI6IHsgdG9rZW46IFwiZGVsaW1pdGVyXCIgfSxcbiAgICAgICAgICAgICAgXCJAZGVmYXVsdFwiOiB7IHRva2VuOiBcIm9wZXJhdG9yc1wiIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIC8vIElkZW50aWZpZXJzXG4gICAgICAgIFtcbiAgICAgICAgICAvQGlkLyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjYXNlczoge1xuICAgICAgICAgICAgICBcIkBrZXl3b3Jkc1wiOiB7IHRva2VuOiBcImtleXdvcmQuJDBcIiB9LFxuICAgICAgICAgICAgICBcIkBzdHJpbmdPcGVyYXRvcnNcIjogeyB0b2tlbjogXCJvcGVyYXRvcnNcIiB9LFxuICAgICAgICAgICAgICBcIkBkZWZhdWx0XCI6IHsgdG9rZW46IFwiaWRlbnRpZmllclwiIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIC8vIDxPUEVOX0JSQUNLRVQgOiBcIltcIj5cbiAgICAgICAgLy8gPENMT1NFX0JSQUNLRVQgOiBcIl1cIj5cbiAgICAgICAgLy8gPE9QRU5fUEFSRU4gOiBcIihcIj5cbiAgICAgICAgLy8gPENMT1NFX1BBUkVOIDogXCIpXCI+XG4gICAgICAgIC8vIDxPUEVOSU5HX0NVUkxZX0JSQUNLRVQgOiBcIntcIj5cbiAgICAgICAgLy8gPENMT1NJTkdfQ1VSTFlfQlJBQ0tFVCA6IFwifVwiPlxuICAgICAgICBbXG4gICAgICAgICAgL1tcXFtcXF1cXChcXClcXHtcXH1dLyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjYXNlczoge1xuICAgICAgICAgICAgICBcIlxcXFxbXCI6IHtcbiAgICAgICAgICAgICAgICBjYXNlczoge1xuICAgICAgICAgICAgICAgICAgXCIkUzI9PWd0XCI6IHsgdG9rZW46IFwiQGJyYWNrZXRzXCIsIG5leHQ6IHMoXCJAaW5QYXJlbl9faWRfXy5ndFwiKSB9LFxuICAgICAgICAgICAgICAgICAgXCJAZGVmYXVsdFwiOiB7IHRva2VuOiBcIkBicmFja2V0c1wiLCBuZXh0OiBzKFwiQGluUGFyZW5fX2lkX18ucGxhaW5cIikgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJcXFxcXVwiOiB7XG4gICAgICAgICAgICAgICAgY2FzZXM6IHtcbiAgICAgICAgICAgICAgICAgIC4uLmlzLmlkID09PSBcImJyYWNrZXRcIiA/IHtcbiAgICAgICAgICAgICAgICAgICAgXCIkUzI9PWludGVycG9sYXRpb25cIjogeyB0b2tlbjogXCJAYnJhY2tldHMuaW50ZXJwb2xhdGlvblwiLCBuZXh0OiBcIkBwb3BhbGxcIiB9XG4gICAgICAgICAgICAgICAgICB9IDoge30sXG4gICAgICAgICAgICAgICAgICAvLyBUaGlzIGNhbm5vdCBoYXBwZW4gd2hpbGUgaW4gYXV0byBtb2RlLCBzaW5jZSB0aGlzIGFwcGxpZXMgb25seSB0byBhblxuICAgICAgICAgICAgICAgICAgLy8gZm1FeHByZXNzaW9uIGluc2lkZSBhIGRpcmVjdGl2ZS4gQnV0IG9uY2Ugd2UgZW5jb3VudGVyIHRoZSBzdGFydCBvZiBhXG4gICAgICAgICAgICAgICAgICAvLyBkaXJlY3RpdmUsIHdlIGNhbiBlc3RhYmxpc2ggdGhlIHRhZyBzeW50YXggbW9kZS5cbiAgICAgICAgICAgICAgICAgIC4uLnRzLmlkID09PSBcImJyYWNrZXRcIiA/IHtcbiAgICAgICAgICAgICAgICAgICAgXCIkUzI9PWRpcmVjdGl2ZVwiOiB7IHRva2VuOiBcIkBicmFja2V0cy5kaXJlY3RpdmVcIiwgbmV4dDogXCJAcG9wYWxsXCIgfVxuICAgICAgICAgICAgICAgICAgfSA6IHt9LFxuICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIG1pc21hdGNoZWQgcGFyZW5cbiAgICAgICAgICAgICAgICAgIFtzKFwiJFMxPT1pblBhcmVuX19pZF9fXCIpXTogeyB0b2tlbjogXCJAYnJhY2tldHNcIiwgbmV4dDogXCJAcG9wXCIgfSxcbiAgICAgICAgICAgICAgICAgIFwiQGRlZmF1bHRcIjogeyB0b2tlbjogXCJAYnJhY2tldHNcIiB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcIlxcXFwoXCI6IHsgdG9rZW46IFwiQGJyYWNrZXRzXCIsIG5leHQ6IHMoXCJAaW5QYXJlbl9faWRfXy5ndFwiKSB9LFxuICAgICAgICAgICAgICBcIlxcXFwpXCI6IHtcbiAgICAgICAgICAgICAgICBjYXNlczoge1xuICAgICAgICAgICAgICAgICAgW3MoXCIkUzE9PWluUGFyZW5fX2lkX19cIildOiB7IHRva2VuOiBcIkBicmFja2V0c1wiLCBuZXh0OiBcIkBwb3BcIiB9LFxuICAgICAgICAgICAgICAgICAgXCJAZGVmYXVsdFwiOiB7IHRva2VuOiBcIkBicmFja2V0c1wiIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiXFxcXHtcIjoge1xuICAgICAgICAgICAgICAgIGNhc2VzOiB7XG4gICAgICAgICAgICAgICAgICBcIiRTMj09Z3RcIjogeyB0b2tlbjogXCJAYnJhY2tldHNcIiwgbmV4dDogcyhcIkBpblBhcmVuX19pZF9fLmd0XCIpIH0sXG4gICAgICAgICAgICAgICAgICBcIkBkZWZhdWx0XCI6IHsgdG9rZW46IFwiQGJyYWNrZXRzXCIsIG5leHQ6IHMoXCJAaW5QYXJlbl9faWRfXy5wbGFpblwiKSB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcIlxcXFx9XCI6IHtcbiAgICAgICAgICAgICAgICBjYXNlczoge1xuICAgICAgICAgICAgICAgICAgLi4uaXMuaWQgPT09IFwiYnJhY2tldFwiID8ge30gOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiJFMyPT1pbnRlcnBvbGF0aW9uXCI6IHsgdG9rZW46IFwiQGJyYWNrZXRzLmludGVycG9sYXRpb25cIiwgbmV4dDogXCJAcG9wYWxsXCIgfVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBtaXNtYXRjaGVkIHBhcmVuXG4gICAgICAgICAgICAgICAgICBbcyhcIiRTMT09aW5QYXJlbl9faWRfX1wiKV06IHsgdG9rZW46IFwiQGJyYWNrZXRzXCIsIG5leHQ6IFwiQHBvcFwiIH0sXG4gICAgICAgICAgICAgICAgICBcIkBkZWZhdWx0XCI6IHsgdG9rZW46IFwiQGJyYWNrZXRzXCIgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgLy8gPE9QRU5fTUlTUExBQ0VEX0lOVEVSUE9MQVRJT04gOiBcIiR7XCIgfCBcIiN7XCIgfCBcIls9XCI+XG4gICAgICAgIFsvXFwkXFx7LywgeyB0b2tlbjogXCJkZWxpbWl0ZXIuaW52YWxpZFwiIH1dXG4gICAgICBdLFxuICAgICAgLy8gPEZNX0VYUFJFU1NJT04sIElOX1BBUkVOLCBOQU1FRF9QQVJBTUVURVJfRVhQUkVTU0lPTj4gU0tJUCA6XG4gICAgICBbcyhcImJsYW5rX2FuZF9leHByZXNzaW9uX2NvbW1lbnRfdG9rZW5fX2lkX19cIildOiBbXG4gICAgICAgIC8vIDwgKCBcIiBcIiB8IFwiXFx0XCIgfCBcIlxcblwiIHwgXCJcXHJcIiApKyA+XG4gICAgICAgIFsvKD86QGJsYW5rKSsvLCB7IHRva2VuOiBcIlwiIH1dLFxuICAgICAgICAvLyA8IChcIjxcIiB8IFwiW1wiKSAoXCIjXCIgfCBcIiFcIikgXCItLVwiPiA6IEVYUFJFU1NJT05fQ09NTUVOVFxuICAgICAgICBbL1s8XFxbXVsjIV0tLS8sIHsgdG9rZW46IFwiY29tbWVudFwiLCBuZXh0OiBzKFwiQGV4cHJlc3Npb25Db21tZW50X19pZF9fXCIpIH1dXG4gICAgICBdLFxuICAgICAgLy8gPEZNX0VYUFJFU1NJT04sIE5PX1NQQUNFX0VYUFJFU1NJT04sIE5BTUVEX1BBUkFNRVRFUl9FWFBSRVNTSU9OPiBUT0tFTiA6XG4gICAgICBbcyhcImRpcmVjdGl2ZV9lbmRfdG9rZW5fX2lkX19cIildOiBbXG4gICAgICAgIC8vIDxESVJFQ1RJVkVfRU5EIDogXCI+XCI+XG4gICAgICAgIC8vIHtcbiAgICAgICAgLy8gICAgIGlmIChpbkZUTEhlYWRlcikge1xuICAgICAgICAvLyAgICAgICAgIGVhdE5ld2xpbmUoKTtcbiAgICAgICAgLy8gICAgICAgICBpbkZUTEhlYWRlciA9IGZhbHNlO1xuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyAgICAgaWYgKHNxdUJyYWNUYWdTeW50YXggfHwgcG9zdEludGVycG9sYXRpb25MZXhTdGF0ZSAhPSAtMSAvKiBXZSBhcmUgaW4gYW4gaW50ZXJwb2xhdGlvbiAqLykge1xuICAgICAgICAvLyAgICAgICAgIG1hdGNoZWRUb2tlbi5raW5kID0gTkFUVVJBTF9HVDtcbiAgICAgICAgLy8gICAgIH0gZWxzZSB7XG4gICAgICAgIC8vICAgICAgICAgU3dpdGNoVG8oREVGQVVMVCk7XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gVGhpcyBjYW5ub3QgaGFwcGVuIHdoaWxlIGluIGF1dG8gbW9kZSwgc2luY2UgdGhpcyBhcHBsaWVzIG9ubHkgdG8gYW5cbiAgICAgICAgLy8gZm1FeHByZXNzaW9uIGluc2lkZSBhIGRpcmVjdGl2ZS4gQnV0IG9uY2Ugd2UgZW5jb3VudGVyIHRoZSBzdGFydCBvZiBhXG4gICAgICAgIC8vIGRpcmVjdGl2ZSwgd2UgY2FuIGVzdGFibGlzaCB0aGUgdGFnIHN5bnRheCBtb2RlLlxuICAgICAgICBbXG4gICAgICAgICAgLz4vLFxuICAgICAgICAgIHRzLmlkID09PSBcImJyYWNrZXRcIiA/IHsgdG9rZW46IFwib3BlcmF0b3JzXCIgfSA6IHsgdG9rZW46IFwiQGJyYWNrZXRzLmRpcmVjdGl2ZVwiLCBuZXh0OiBcIkBwb3BhbGxcIiB9XG4gICAgICAgIF0sXG4gICAgICAgIC8vIDxFTVBUWV9ESVJFQ1RJVkVfRU5EIDogXCIvPlwiIHwgXCIvXVwiPlxuICAgICAgICAvLyBJdCBpcyBhIHN5bnRheCBlcnJvciB0byBlbmQgYSB0YWcgd2l0aCB0aGUgd3JvbmcgY2xvc2UgdG9rZW5cbiAgICAgICAgLy8gTGV0J3MgaW5kaWNhdGUgdGhhdCB0byB0aGUgdXNlciBieSBub3QgY2xvc2luZyB0aGUgdGFnXG4gICAgICAgIFtcbiAgICAgICAgICByKC8oXFwvKShAY2xvc2VfX2lkX18pLyksXG4gICAgICAgICAgW3sgdG9rZW46IFwiZGVsaW1pdGVyLmRpcmVjdGl2ZVwiIH0sIHsgdG9rZW46IFwiQGJyYWNrZXRzLmRpcmVjdGl2ZVwiLCBuZXh0OiBcIkBwb3BhbGxcIiB9XVxuICAgICAgICBdXG4gICAgICBdLFxuICAgICAgLy8gPElOX1BBUkVOPiBUT0tFTiA6XG4gICAgICBbcyhcImdyZWF0ZXJfb3BlcmF0b3JzX3Rva2VuX19pZF9fXCIpXTogW1xuICAgICAgICAvLyA8TkFUVVJBTF9HVCA6IFwiPlwiPlxuICAgICAgICBbLz4vLCB7IHRva2VuOiBcIm9wZXJhdG9yc1wiIH1dLFxuICAgICAgICAvLyA8TkFUVVJBTF9HVEUgOiBcIj49XCI+XG4gICAgICAgIFsvPj0vLCB7IHRva2VuOiBcIm9wZXJhdG9yc1wiIH1dXG4gICAgICBdLFxuICAgICAgLy8gPE5PX1NQQUNFX0VYUFJFU1NJT04+IFRPS0VOIDpcbiAgICAgIFtzKFwibm9fc3BhY2VfZXhwcmVzc2lvbl9lbmRfdG9rZW5fX2lkX19cIildOiBbXG4gICAgICAgIC8vIDxURVJNSU5BVElOR19XSElURVNQQUNFIDogIChbXCJcXG5cIiwgXCJcXHJcIiwgXCJcXHRcIiwgXCIgXCJdKSs+IDogRk1fRVhQUkVTU0lPTlxuICAgICAgICBbLyg/OkBibGFuaykrLywgeyB0b2tlbjogXCJcIiwgc3dpdGNoVG86IHMoXCJAZm1FeHByZXNzaW9uX19pZF9fLmRpcmVjdGl2ZVwiKSB9XVxuICAgICAgXSxcbiAgICAgIFtzKFwidW5pZmllZF9jYWxsX3Rva2VuX19pZF9fXCIpXTogW1xuICAgICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgY2FsbCB3aGVyZSB0aGUgZXhwcmVzc2lvbiBpcyBqdXN0IGFuIElEXG4gICAgICAgIC8vIDxVTklGSUVEX0NBTEw+IDxJRD4gPEJMQU5LPitcbiAgICAgICAgW1xuICAgICAgICAgIC8oQGlkKSgoPzpAYmxhbmspKykvLFxuICAgICAgICAgIFt7IHRva2VuOiBcInRhZ1wiIH0sIHsgdG9rZW46IFwiXCIsIG5leHQ6IHMoXCJAZm1FeHByZXNzaW9uX19pZF9fLmRpcmVjdGl2ZVwiKSB9XVxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgcigvKEBpZCkoXFwvPykoQGNsb3NlX19pZF9fKS8pLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIHsgdG9rZW46IFwidGFnXCIgfSxcbiAgICAgICAgICAgIHsgdG9rZW46IFwiZGVsaW1pdGVyLmRpcmVjdGl2ZVwiIH0sXG4gICAgICAgICAgICB7IHRva2VuOiBcIkBicmFja2V0cy5kaXJlY3RpdmVcIiwgbmV4dDogXCJAcG9wYWxsXCIgfVxuICAgICAgICAgIF1cbiAgICAgICAgXSxcbiAgICAgICAgWy8uLywgeyB0b2tlbjogXCJAcmVtYXRjaFwiLCBuZXh0OiBzKFwiQG5vU3BhY2VFeHByZXNzaW9uX19pZF9fXCIpIH1dXG4gICAgICBdLFxuICAgICAgLy8gPE5PX1BBUlNFPiBUT0tFTiA6XG4gICAgICBbcyhcIm5vX3BhcnNlX3Rva2VuX19pZF9fXCIpXTogW1xuICAgICAgICAvLyA8TUFZQkVfRU5EIDpcbiAgICAgICAgLy8gXHQgKFwiPFwiIHwgXCJbXCIpXG4gICAgICAgIC8vIFx0IFwiL1wiXG4gICAgICAgIC8vIFx0IChcIiNcIik/XG4gICAgICAgIC8vIFx0IChbXCJhXCItXCJ6XCIsIFwiQVwiLVwiWlwiXSkrXG4gICAgICAgIC8vIFx0ICggXCIgXCIgfCBcIlxcdFwiIHwgXCJcXG5cIiB8IFwiXFxyXCIgKSpcbiAgICAgICAgLy8gXHQgKFwiPlwiIHwgXCJdXCIpXG4gICAgICAgIC8vID5cbiAgICAgICAgW1xuICAgICAgICAgIHIoLyhAb3Blbl9faWRfXykoXFwvIz8pKFthLXpBLVpdKykoKD86QGJsYW5rKSopKEBjbG9zZV9faWRfXykvKSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjYXNlczoge1xuICAgICAgICAgICAgICBcIiRTMj09JDNcIjogW1xuICAgICAgICAgICAgICAgIHsgdG9rZW46IFwiQGJyYWNrZXRzLmRpcmVjdGl2ZVwiIH0sXG4gICAgICAgICAgICAgICAgeyB0b2tlbjogXCJkZWxpbWl0ZXIuZGlyZWN0aXZlXCIgfSxcbiAgICAgICAgICAgICAgICB7IHRva2VuOiBcInRhZ1wiIH0sXG4gICAgICAgICAgICAgICAgeyB0b2tlbjogXCJcIiB9LFxuICAgICAgICAgICAgICAgIHsgdG9rZW46IFwiQGJyYWNrZXRzLmRpcmVjdGl2ZVwiLCBuZXh0OiBcIkBwb3BhbGxcIiB9XG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIFwiJFMyPT1jb21tZW50XCI6IFtcbiAgICAgICAgICAgICAgICB7IHRva2VuOiBcImNvbW1lbnRcIiB9LFxuICAgICAgICAgICAgICAgIHsgdG9rZW46IFwiY29tbWVudFwiIH0sXG4gICAgICAgICAgICAgICAgeyB0b2tlbjogXCJjb21tZW50XCIgfSxcbiAgICAgICAgICAgICAgICB7IHRva2VuOiBcImNvbW1lbnRcIiB9LFxuICAgICAgICAgICAgICAgIHsgdG9rZW46IFwiY29tbWVudFwiIH1cbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgXCJAZGVmYXVsdFwiOiBbXG4gICAgICAgICAgICAgICAgeyB0b2tlbjogXCJzb3VyY2VcIiB9LFxuICAgICAgICAgICAgICAgIHsgdG9rZW46IFwic291cmNlXCIgfSxcbiAgICAgICAgICAgICAgICB7IHRva2VuOiBcInNvdXJjZVwiIH0sXG4gICAgICAgICAgICAgICAgeyB0b2tlbjogXCJzb3VyY2VcIiB9LFxuICAgICAgICAgICAgICAgIHsgdG9rZW46IFwic291cmNlXCIgfVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICAvLyA8S0VFUF9HT0lORyA6ICh+W1wiPFwiLCBcIltcIiwgXCItXCJdKSs+XG4gICAgICAgIC8vIDxMT05FX0xFU1NfVEhBTl9PUl9EQVNIIDogW1wiPFwiLCBcIltcIiwgXCItXCJdPlxuICAgICAgICBbXG4gICAgICAgICAgL1tePFxcW1xcLV0rfFs8XFxbXFwtXS8sXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2FzZXM6IHtcbiAgICAgICAgICAgICAgXCIkUzI9PWNvbW1lbnRcIjogeyB0b2tlbjogXCJjb21tZW50XCIgfSxcbiAgICAgICAgICAgICAgXCJAZGVmYXVsdFwiOiB7IHRva2VuOiBcInNvdXJjZVwiIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIF0sXG4gICAgICAvLyA8RVhQUkVTU0lPTl9DT01NRU5UPiBTS0lQOlxuICAgICAgW3MoXCJleHByZXNzaW9uX2NvbW1lbnRfdG9rZW5fX2lkX19cIildOiBbXG4gICAgICAgIC8vIDwgXCItLT5cIiB8IFwiLS1dXCI+XG4gICAgICAgIFtcbiAgICAgICAgICAvLS1bPlxcXV0vLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRva2VuOiBcImNvbW1lbnRcIixcbiAgICAgICAgICAgIG5leHQ6IFwiQHBvcFwiXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICAvLyA8ICh+W1wiLVwiLCBcIj5cIiwgXCJdXCJdKSsgPlxuICAgICAgICAvLyA8IFwiPlwiPlxuICAgICAgICAvLyA8IFwiXVwiPlxuICAgICAgICAvLyA8IFwiLVwiPlxuICAgICAgICBbL1teXFwtPlxcXV0rfFs+XFxdXFwtXS8sIHsgdG9rZW46IFwiY29tbWVudFwiIH1dXG4gICAgICBdLFxuICAgICAgW3MoXCJ0ZXJzZV9jb21tZW50X3Rva2VuX19pZF9fXCIpXTogW1xuICAgICAgICAvLyAgPFRFUlNFX0NPTU1FTlRfRU5EIDogXCItLT5cIiB8IFwiLS1dXCI+XG4gICAgICAgIFtyKC8tLSg/OkBjbG9zZV9faWRfXykvKSwgeyB0b2tlbjogXCJjb21tZW50XCIsIG5leHQ6IFwiQHBvcGFsbFwiIH1dLFxuICAgICAgICAvLyA8S0VFUF9HT0lORyA6ICh+W1wiPFwiLCBcIltcIiwgXCItXCJdKSs+XG4gICAgICAgIC8vIDxMT05FX0xFU1NfVEhBTl9PUl9EQVNIIDogW1wiPFwiLCBcIltcIiwgXCItXCJdPlxuICAgICAgICBbL1tePFxcW1xcLV0rfFs8XFxbXFwtXS8sIHsgdG9rZW46IFwiY29tbWVudFwiIH1dXG4gICAgICBdXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlTW9uYXJjaExhbmd1YWdlQXV0byhpcykge1xuICBjb25zdCBhbmdsZSA9IGNyZWF0ZU1vbmFyY2hMYW5ndWFnZShUYWdTeW50YXhBbmdsZSwgaXMpO1xuICBjb25zdCBicmFja2V0ID0gY3JlYXRlTW9uYXJjaExhbmd1YWdlKFRhZ1N5bnRheEJyYWNrZXQsIGlzKTtcbiAgY29uc3QgYXV0byA9IGNyZWF0ZU1vbmFyY2hMYW5ndWFnZShUYWdTeW50YXhBdXRvLCBpcyk7XG4gIHJldHVybiB7XG4gICAgLy8gQW5nbGUgYW5kIGJyYWNrZXQgc3ludGF4IG1vZGVcbiAgICAvLyBXZSBzd2l0Y2ggdG8gb25lIG9mIHRoZXNlIG9uY2Ugd2UgaGF2ZSBkZXRlcm1pbmVkIHRoZSBtb2RlXG4gICAgLi4uYW5nbGUsXG4gICAgLi4uYnJhY2tldCxcbiAgICAuLi5hdXRvLFxuICAgIC8vIFNldHRpbmdzXG4gICAgdW5pY29kZTogdHJ1ZSxcbiAgICBpbmNsdWRlTEY6IGZhbHNlLFxuICAgIHN0YXJ0OiBgZGVmYXVsdF9hdXRvXyR7aXMuaWR9YCxcbiAgICBpZ25vcmVDYXNlOiBmYWxzZSxcbiAgICBkZWZhdWx0VG9rZW46IFwiaW52YWxpZFwiLFxuICAgIHRva2VuUG9zdGZpeDogYC5mcmVlbWFya2VyMmAsXG4gICAgYnJhY2tldHM6IFtcbiAgICAgIHsgb3BlbjogXCJ7XCIsIGNsb3NlOiBcIn1cIiwgdG9rZW46IFwiZGVsaW1pdGVyLmN1cmx5XCIgfSxcbiAgICAgIHsgb3BlbjogXCJbXCIsIGNsb3NlOiBcIl1cIiwgdG9rZW46IFwiZGVsaW1pdGVyLnNxdWFyZVwiIH0sXG4gICAgICB7IG9wZW46IFwiKFwiLCBjbG9zZTogXCIpXCIsIHRva2VuOiBcImRlbGltaXRlci5wYXJlbnRoZXNpc1wiIH0sXG4gICAgICB7IG9wZW46IFwiPFwiLCBjbG9zZTogXCI+XCIsIHRva2VuOiBcImRlbGltaXRlci5hbmdsZVwiIH1cbiAgICBdLFxuICAgIHRva2VuaXplcjoge1xuICAgICAgLi4uYW5nbGUudG9rZW5pemVyLFxuICAgICAgLi4uYnJhY2tldC50b2tlbml6ZXIsXG4gICAgICAuLi5hdXRvLnRva2VuaXplclxuICAgIH1cbiAgfTtcbn1cbnZhciBUYWdBbmdsZUludGVycG9sYXRpb25Eb2xsYXIgPSB7XG4gIGNvbmY6IGNyZWF0ZUxhbmdDb25maWd1cmF0aW9uKFRhZ1N5bnRheEFuZ2xlKSxcbiAgbGFuZ3VhZ2U6IGNyZWF0ZU1vbmFyY2hMYW5ndWFnZShUYWdTeW50YXhBbmdsZSwgSW50ZXJwb2xhdGlvblN5bnRheERvbGxhcilcbn07XG52YXIgVGFnQnJhY2tldEludGVycG9sYXRpb25Eb2xsYXIgPSB7XG4gIGNvbmY6IGNyZWF0ZUxhbmdDb25maWd1cmF0aW9uKFRhZ1N5bnRheEJyYWNrZXQpLFxuICBsYW5ndWFnZTogY3JlYXRlTW9uYXJjaExhbmd1YWdlKFRhZ1N5bnRheEJyYWNrZXQsIEludGVycG9sYXRpb25TeW50YXhEb2xsYXIpXG59O1xudmFyIFRhZ0FuZ2xlSW50ZXJwb2xhdGlvbkJyYWNrZXQgPSB7XG4gIGNvbmY6IGNyZWF0ZUxhbmdDb25maWd1cmF0aW9uKFRhZ1N5bnRheEFuZ2xlKSxcbiAgbGFuZ3VhZ2U6IGNyZWF0ZU1vbmFyY2hMYW5ndWFnZShUYWdTeW50YXhBbmdsZSwgSW50ZXJwb2xhdGlvblN5bnRheEJyYWNrZXQpXG59O1xudmFyIFRhZ0JyYWNrZXRJbnRlcnBvbGF0aW9uQnJhY2tldCA9IHtcbiAgY29uZjogY3JlYXRlTGFuZ0NvbmZpZ3VyYXRpb24oVGFnU3ludGF4QnJhY2tldCksXG4gIGxhbmd1YWdlOiBjcmVhdGVNb25hcmNoTGFuZ3VhZ2UoVGFnU3ludGF4QnJhY2tldCwgSW50ZXJwb2xhdGlvblN5bnRheEJyYWNrZXQpXG59O1xudmFyIFRhZ0F1dG9JbnRlcnBvbGF0aW9uRG9sbGFyID0ge1xuICBjb25mOiBjcmVhdGVMYW5nQ29uZmlndXJhdGlvbkF1dG8oKSxcbiAgbGFuZ3VhZ2U6IGNyZWF0ZU1vbmFyY2hMYW5ndWFnZUF1dG8oSW50ZXJwb2xhdGlvblN5bnRheERvbGxhcilcbn07XG52YXIgVGFnQXV0b0ludGVycG9sYXRpb25CcmFja2V0ID0ge1xuICBjb25mOiBjcmVhdGVMYW5nQ29uZmlndXJhdGlvbkF1dG8oKSxcbiAgbGFuZ3VhZ2U6IGNyZWF0ZU1vbmFyY2hMYW5ndWFnZUF1dG8oSW50ZXJwb2xhdGlvblN5bnRheEJyYWNrZXQpXG59O1xuZXhwb3J0IHtcbiAgVGFnQW5nbGVJbnRlcnBvbGF0aW9uQnJhY2tldCxcbiAgVGFnQW5nbGVJbnRlcnBvbGF0aW9uRG9sbGFyLFxuICBUYWdBdXRvSW50ZXJwb2xhdGlvbkJyYWNrZXQsXG4gIFRhZ0F1dG9JbnRlcnBvbGF0aW9uRG9sbGFyLFxuICBUYWdCcmFja2V0SW50ZXJwb2xhdGlvbkJyYWNrZXQsXG4gIFRhZ0JyYWNrZXRJbnRlcnBvbGF0aW9uRG9sbGFyXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/basic-languages/freemarker2/freemarker2.js\n");

/***/ })

}]);